/*
This is part of the audio CD player library
Copyright (C)1998-99 Tony Arcieri <bascule@inferno.tusculum.edu>
Copyright (C)2001,2002 Dustin Graves <dgraves@computer.org>

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with this library; if not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA  02111-1307, USA.
*/

#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <string.h>
#include <errno.h>
#include <time.h>

#ifndef WIN32
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#else
#include <winsock2.h>
#include <windows.h>

#define strcasecmp  _stricmp
#define strncasecmp _strnicmp
#define snprintf _snprintf
#endif

#ifndef INADDR_NONE
#define INADDR_NONE 0xFFFFFFFF
#endif

#ifndef PATH_MAX
#if defined(_MAX_PATH)
#define PATH_MAX  _MAX_PATH
#elif defined(MAX_PATH)
#define PATH_MAX  MAX_PATH
#else
#define PATH_MAX  1024
#endif
#endif

#include "cdlyte.h"

/* Some procedures differ on Windows.  */
#ifndef WIN32
#define PATHSEP '/'
#define cddb_close close
#else
#define PATHSEP '\\'
#define cddb_close closesocket
#endif

/* Global cddb_message definition */
char cddb_message[256];

/* Local structs for cddb_read input processing.  Hold char count for char arrays to prevent array bounds write */
struct __track_data {
  int ttitle_len;                  /* Amount of data in ttitle field */
  char ttitle[EXTENDED_DATA_SIZE]; /* Concatenate all TTITLE lines before parsing */
  int ext_len;                     /* Amount of data in corresponding track_data field */
};

struct __disc_data {
  int dtitle_len;                  /* Amount of data in dtitle field */
  char dtitle[EXTENDED_DATA_SIZE]; /* Concatenate all DTITLE lines before parsing */
  int genre_len;                   /* Amount of data in corresponding disc_data field */
  int ext_len;                     /* Amount of data in corresponding disc_data field */
  int track_total;                 /* Number of tracks */
  struct __track_data track[MAX_TRACKS];
};

/* CDDB sum function */
static int cddb_sum(int val)
{
  char *bufptr,buf[16];
  int ret=0;

  snprintf(buf,16,"%u",val);
  for(bufptr=buf;*bufptr!='\0';bufptr++)
    ret+=(*bufptr-'0');

  return ret;
}

/**
 * Return CDDB ID for CD in device with handle cd_desc.  
 * @param cd_desc the handle to the cd device containing CD from which to obtain CDDB ID.  
 * @return calculated CDDB ID on success, -1 on failure.  
 */
unsigned long cddb_discid(cddesc_t cd_desc)
{
  int index,discid,tracksum=0;
  struct disc_info disc;

  if(cd_stat(cd_desc,&disc)<0)
    return -1;

  if(!disc.disc_present)
    return -1;

  for(index=0;index<disc.disc_total_tracks;index++)
    tracksum+=cddb_sum(disc.disc_track[index].track_pos.minutes*60+disc.disc_track[index].track_pos.seconds);

  discid=(disc.disc_length.minutes*60+disc.disc_length.seconds)-(disc.disc_track[0].track_pos.minutes*60+disc.disc_track[0].track_pos.seconds);

  return ((tracksum%0xFF)<<24|discid<<8|disc.disc_total_tracks)&0xFFFFFFFF;
}

/**
 * Create a CDDB query string for the CD in device with handle cd_desc.  
 * The query string is used to query the CDDB server for exact and inexact 
 * database entries for a CD.  The string generated by this function is 
 * intended to be used with the function 'cddb_query'.  
 * @param cd_desc the handle to the cd device containing the cd from which to calculate the CDDB query string.  
 * @param query a character array in which to store the computed CDDB query string.  
 * @param len an integer specifying the size of 'query'.  
 * @return a pointer to 'query' on success, NULL on failure.  
 */
char* cddb_query_string(cddesc_t cd_desc,char *query,int len)
{
  int index;
  unsigned long discid;
  char outtemp[1024];
  struct disc_info disc;

  if(cd_stat(cd_desc,&disc)<0)
    return NULL;

  if((discid=cddb_discid(cd_desc))==-1)
    return NULL;

  snprintf(outtemp,sizeof(outtemp),"%d",disc.disc_total_tracks);
  for(index=0;index<disc.disc_total_tracks;index++)
  {
    strncpy(query,outtemp,len);
    snprintf(outtemp,sizeof(outtemp),"%s %d",query,(disc.disc_track[index].track_pos.minutes*60+disc.disc_track[index].track_pos.seconds)*75+disc.disc_track[index].track_pos.frames);
  }

  snprintf(query,len,"%08lx %s %d",discid,outtemp,disc.disc_length.minutes*60+disc.disc_length.seconds);
  return query;
}

/**
 * Create a generic entry for an unrecognized disc.  
 * The generated data may be used to represent a disc when 
 * a real entry is not found in the CDDB database or CDDB is 
 * unavailable.  
 * @param cd_desc the handle to the cd device containing the 
 *        cd from which to data should be generated.  
 * @param data a disc_data structure to be filled with the generated data.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_gen_unknown_entry(cddesc_t cd_desc,struct disc_data *data)
{
  struct disc_info disc;

  if(cd_stat(cd_desc,&disc)<0)
    return -1;

  if((data->data_id=cddb_discid(cd_desc))==-1)
    return -1;

  memset(data,0,sizeof(*data));
  data->data_category=CDDB_UNKNOWN;

  return 0;
}

/**
 * Allocate exact ammount of memory required for CDDB data structure.  
 * @param data pointer for allocated memory.  
 * @param tracks number of tracks to allocate space for.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_mc_alloc(struct disc_mc_data *data,int tracks)
{
  int index;

  data->data_id=0;
  data->data_category=CDDB_UNKNOWN;
  data->data_revision=0;
  data->data_total_tracks=tracks;
  data->data_artist=NULL;
  data->data_title=NULL;
  data->data_year=NULL;
  data->data_genre=NULL;
  data->data_extended=NULL;

  if((data->data_track=calloc(tracks,sizeof(struct track_mc_data)))==NULL)
    return -1;

  for(index=0;index<tracks;index++)
  {
    data->data_track[index]->track_title=NULL;
    data->data_track[index]->track_artist=NULL;
    data->data_track[index]->track_extended=NULL;
  }

  return 0;
}

/**
 * Free memory allocated for CDDB data structure.  
 * @param data pointer to memory to be freed.  
 */
void cddb_mc_free(struct disc_mc_data *data)
{
  int index=0,tracks=data->data_total_tracks;

  if(data->data_artist!=NULL)
    free(data->data_artist);

  if(data->data_title!=NULL)
    free(data->data_title);

  if(data->data_year!=NULL)
    free(data->data_year);

  if(data->data_genre!=NULL)
    free(data->data_genre);

  if(data->data_extended!=NULL)
    free(data->data_extended);

  for(index=0;index<tracks;index++)
  {
    if(data->data_track[index]->track_title!=NULL)
      free(data->data_track[index]->track_title);
    if(data->data_track[index]->track_artist!=NULL)
      free(data->data_track[index]->track_artist);
    if(data->data_track[index]->track_extended!=NULL)
      free(data->data_track[index]->track_extended);
  }

  free(data->data_track);
}

/**
 * Copy data from (large) fixed size structure to dynamically sized structure.  
 * @param out structure to copy data into.  Must have been previously allocated 
          with cddb_mc_alloc.  
 * @param in structure containing data to be copied.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_mc_copy_from_data(struct disc_mc_data *out,const struct disc_data *in)
{
  int track;

  out->data_id=in->data_id;
  out->data_category=in->data_category;
  out->data_revision=in->data_revision;

  if((out->data_artist=malloc(strlen(in->data_artist)+1))==NULL)
    return -1;
  strncpy(out->data_artist,in->data_artist,sizeof(out->data_artist));

  if((out->data_title=malloc(strlen(in->data_title)+1))==NULL)
    return -1;
  strncpy(out->data_title,in->data_title,sizeof(out->data_title));
   
  if((out->data_year=malloc(strlen(in->data_year)+1))==NULL)
    return -1;
  strncpy(out->data_year,in->data_year,sizeof(out->data_year));
   
  if((out->data_genre=malloc(strlen(in->data_genre)+1))==NULL)
    return -1;
  strncpy(out->data_genre,in->data_genre,sizeof(out->data_genre));
   
  if((out->data_extended=malloc(strlen(in->data_extended)+1))==NULL)
    return -1;
  strncpy(out->data_extended,in->data_extended,sizeof(out->data_extended));

  for(track=0;track<out->data_total_tracks;track++)
  {
    if((out->data_track[track]->track_title=malloc(strlen(in->data_track[track].track_title)+1))==NULL)
      return -1;
    strncpy(out->data_track[track]->track_title,in->data_track[track].track_title,sizeof(out->data_track[track]->track_title));

    if((out->data_track[track]->track_artist=malloc(strlen(in->data_track[track].track_artist)+1))==NULL)
      return -1;
    strncpy(out->data_track[track]->track_artist,in->data_track[track].track_artist,sizeof(out->data_track[track]->track_artist));

    if((out->data_track[track]->track_extended=malloc(strlen(in->data_track[track].track_extended)+1))==NULL)
      return -1;
    strncpy(out->data_track[track]->track_extended,in->data_track[track].track_extended,sizeof(out->data_track[track]->track_extended));
  }

  return 0;
}

/**
 * Copy data from dynamically allocated structure to (large) fixed size structure.  
 * @param out structure to copy data into.  
 * @param in structure containing data to be copied.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_data_copy_from_mc(struct disc_data *out,const struct disc_mc_data *in)
{
  int track;

  out->data_id=in->data_id;
  out->data_category=in->data_category;
  out->data_revision=in->data_revision;
  out->data_total_tracks=in->data_total_tracks;

  strncpy(out->data_artist,in->data_artist,sizeof(out->data_artist));
  strncpy(out->data_title,in->data_title,sizeof(out->data_title));
  strncpy(out->data_year,in->data_year,sizeof(out->data_year));
  strncpy(out->data_genre,in->data_genre,sizeof(out->data_genre));
  strncpy(out->data_extended,in->data_extended,sizeof(out->data_extended));

  for(track=0;track<in->data_total_tracks;track++)
  {
    strncpy(out->data_track[track].track_title,in->data_track[track]->track_title,sizeof(out->data_track[track].track_title));
    strncpy(out->data_track[track].track_artist,in->data_track[track]->track_artist,sizeof(out->data_track[track].track_artist));
    strncpy(out->data_track[track].track_extended,in->data_track[track]->track_extended,sizeof(out->data_track[track].track_extended));
  }

   return 0;
}

/**
 * Extract CDDB protocol, server address and port, and CGI script from URL.  
 * @param host structure into which extracted information is to be copied.  
 * @param url string with the URL to be processed.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_process_url(struct cddb_host *host,const char *url)
{
  int index=0;
  char port[6];

  if(strchr(url,':')==NULL)
    return -1;

  while(url[index++]!=':')
  {
    if(index>5)
      return -1;
  }

  if(strncmp(url,"http",index-1)==0)
  {
    host->host_protocol=CDDB_MODE_HTTP;
    host->host_server.server_port=HTTP_DEFAULT_PORT;
  }
  else if(strncmp(url,"cddbp",index-1)==0)
  {
    host->host_protocol=CDDB_MODE_CDDBP;
    host->host_server.server_port=CDDBP_DEFAULT_PORT;
  }
  else
    return -1;

  url+=(index-1);

  if(strncmp(url,"://",3)!=0)
    return -1;

  url+=3;

  index=0;
  while(url[index]!=':'&&url[index]!='\0'&&url[index]!='/')
  {
    index++;
    if(index>255)
      return -1;
  }

  memset(host->host_server.server_name,'\0',sizeof(host->host_server.server_name));
  strncpy(host->host_server.server_name,url,index);

  if(url[index]==':')
  {
    url+=(index+1);
    index=0;
    while(url[index]!='\0'&&url[index]!='/')
    {
      index++;
      if(index>5)
        return -1;
    }

    memset(port,'\0',sizeof(port));
    strncpy(port,url,index);
    host->host_server.server_port=strtol(port,NULL,10);
  }

  memset(host->host_addressing,'\0',sizeof(host->host_addressing));

  if(url[index]=='/'&&url[index+1]!='\0')
  {
    url+=(index+1);
    index=0;
    while(url[index++]!='\0')
    {
      if(index>255)
        return -1;
    }

    strncpy(host->host_addressing,url,index);
  }

  return 0;
}

/**
 * Convert numerical identifier to text descriptor.  
 * @param category an integer identifying the category.  
 * @param buffer a character array to be used to store the text converted category type.  
 * @param len the size of the character array 'buffer'.  
 * @return a pointer to 'buffer'.  
 */
char* cddb_category(int category,char* buffer,int len)
{
  memset(buffer,0,len);
  switch(category)
  {
    case CDDB_BLUES:
      strncpy(buffer,"blues",len);
    case CDDB_CLASSICAL:
      strncpy(buffer,"classical",len);
    case CDDB_COUNTRY:
      strncpy(buffer,"country",len);
    case CDDB_DATA:
      strncpy(buffer,"data",len);
    case CDDB_FOLK:
      strncpy(buffer,"folk",len);
    case CDDB_JAZZ:
      strncpy(buffer,"jazz",len);
    case CDDB_MISC:
      strncpy(buffer,"misc",len);
    case CDDB_NEWAGE:
      strncpy(buffer,"newage",len);
    case CDDB_REGGAE:
      strncpy(buffer,"reggae",len);
    case CDDB_ROCK:
      strncpy(buffer,"rock",len);
    case CDDB_SOUNDTRACK:
      strncpy(buffer,"soundtrack",len);
    default:
      strncpy(buffer,"unknown",len);
  }

  return buffer;
}

/**
 * Convert category text descriptor to numerical identifier.  
 * @param category text descriptor to convert to numerical identifier.  
 * @return numerical identifier.  
 */
int cddb_category_value(const char *category)
{
  if(strcmp(category,"blues")==0)
    return CDDB_BLUES;
  else if(strcmp(category,"classical")==0)
    return CDDB_CLASSICAL;
  else if(strcmp(category,"country")==0)
    return CDDB_COUNTRY;
  else if(strcmp(category,"data")==0)
    return CDDB_DATA;
  else if(strcmp(category,"folk")==0)
    return CDDB_FOLK;
  else if(strcmp(category,"jazz")==0)
    return CDDB_JAZZ;
  else if(strcmp(category,"misc")==0)
    return CDDB_MISC;
  else if(strcmp(category,"newage")==0)
    return CDDB_NEWAGE;
  else if(strcmp(category,"reggae")==0)
    return CDDB_REGGAE;
  else if(strcmp(category,"rock")==0)
    return CDDB_ROCK;
  else if(strcmp(category,"soundtrack")==0)
    return CDDB_SOUNDTRACK;
  else
    return CDDB_UNKNOWN;
}

/*
 * Connect to a specified CDDB server.  
 * @param server a cddb_server structure specifying the CDDB 
 *        server with which to connect.  
 * @return handle to a connected socket on success, 
 *         INVALID_CDSOCKET on failure.  
 */
static cdsock_t cddb_connect_server(const struct cddb_server *server)
{
  cdsock_t sock;
  struct sockaddr_in sin;
  struct hostent *host;

  sin.sin_family=AF_INET;
  sin.sin_port=htons(server->server_port);
     
  if((sin.sin_addr.s_addr=inet_addr(server->server_name))==INADDR_NONE)
  {
    if((host=gethostbyname(server->server_name))==NULL)
    {
      strncpy(cddb_message,strerror(errno),sizeof(cddb_message));
      return INVALID_CDSOCKET;
    }
      
    memcpy(&sin.sin_addr,host->h_addr,host->h_length);
  }

  if((sock=socket(AF_INET,SOCK_STREAM,0))==INVALID_CDSOCKET)
  {
    strncpy(cddb_message,strerror(errno),sizeof(cddb_message));
    return INVALID_CDSOCKET;
  }

  if(connect(sock,(struct sockaddr *)&sin,sizeof(sin))==CDSOCKET_ERROR)
  {
    strncpy(cddb_message,strerror(errno),sizeof(cddb_message));
    return INVALID_CDSOCKET;
  }

  return sock;
}
  
/* Read a single line.  */
static int cddb_read_line(cdsock_t sock,char *inbuffer,int len)
{
  int index;
  char inchar;

  if(recv(sock,&inchar,1,0)!=1)
    return CDSOCKET_ERROR;

  len--;  /* Make sure their is always a null terminator.  */
  index=0;
  while(inchar!='\n'&&index<len)
  {
    if(inchar!='\r')
      inbuffer[index++]=inchar;
    if(recv(sock,&inchar,1,0)!=1)
      return CDSOCKET_ERROR;
  }

  inbuffer[index]='\0';
  return index;
}

/* 
 * Read server reply to a CDDB command.  Reply consists of an integer code 
 * (indicating either failure or success) and a text description separated by a ' '.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @param message a character array to be filled with the server's reply.  
 * @param len an integer specifying the size of 'message'.  
 * @return 0 on success, CDSOCKET_ERROR on failure.  
 */
static int cddb_read_reply(cdsock_t sock,char *message,int len)
{
  if(cddb_read_line(sock,message,len)==CDSOCKET_ERROR)
    return CDSOCKET_ERROR;

  if(strncmp(message,"<!DOC",5)==0)
    strncpy(message,"404 CDDB CGI not found",len);

  return 0;
}

/**
 * Connect to a specified CDDB server.  If protocol is HTTP, an HTTP initiaition 
 * string will be created.  
 * @param host a cddb_host structure specifying the CDDB 
 *        server with which to connect.  
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value 
 *        should be NULL.  
 * @param hello a variable argument only required when using HTTP.  
 *        This is a cddb_hello structure specifying the name and version 
 *        of the application connecting to the CDDB server.  
 * @param http_string a variable argument only required when using HTTP.  
 *        This is a character array to be filled by the function with a 
 *        CDDB handshake string.  This string will be required for further
 *        HTTP queries.  Note that the string for CDDB queries differs from
 *        the string for CDDB submissions.  When using CDDB with HTTP, separate
 *        connections for CDDB queries and submissions are required.  
 * @param https_string_len a variable argument only required when using HTTP.  
 *        This is an integer specifying the size of the http_string character array.  
 * @return handle to a connected socket on success, 
 *         INVALID_CDSOCKET on failure.  
 */
cdsock_t cddb_connect(const struct cddb_host *host,const struct cddb_server *proxy,...)
{
  cdsock_t sock;
  int http_string_len;
  char *http_string;
  struct cddb_hello *hello;

  if(proxy!=NULL)
  {
    if((sock=cddb_connect_server(proxy))==INVALID_CDSOCKET)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Failed to connect with proxy server");
      return INVALID_CDSOCKET;
    }
  }
  else
  {
    if((sock=cddb_connect_server(&host->host_server))==INVALID_CDSOCKET)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Failed to connect with %s",host->host_server.server_name);
      return INVALID_CDSOCKET;
    }
  }

  if(host->host_protocol==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,proxy);
    hello=va_arg(arglist,struct cddb_hello *);
    http_string=va_arg(arglist,char *);
    http_string_len=va_arg(arglist,int);

    if(proxy!=NULL)
      snprintf(http_string,http_string_len,"GET http://%s:%d%s?hello=%s+%s+%s+%s&proto=%d HTTP/1.0\n\n",host->host_server.server_name,host->host_server.server_port,host->host_addressing,hello->hello_user,hello->hello_hostname,hello->hello_program,hello->hello_version,CDDB_PROTOCOL_LEVEL);
    else
      snprintf(http_string,http_string_len,"GET %s?hello=%s+%s+%s+%s&proto=%d HTTP/1.0\n\n",host->host_addressing,hello->hello_user,hello->hello_hostname,hello->hello_program,hello->hello_version,CDDB_PROTOCOL_LEVEL);

    va_end(arglist);
  }
  else
  {
    if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return INVALID_CDSOCKET;
    }

    if(cddb_message[0]!='2')
    {
      cddb_close(sock);
      return INVALID_CDSOCKET;
    }
  }

  return sock;
}

/**
 * Initiate a CDDB CDDBP connection.  Required after use of 'cddb_connect'.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @param hello a cddb_hello structure specifying the name and version 
 *        of the application connecting to the CDDB server.  
 * @return 1 on handshake success, 0 on handshake failure, and CDSOCKET_ERROR 
 *         on socket failure.  
 */
int cddb_handshake(cdsock_t sock,const struct cddb_hello *hello)
{
  char outbuffer[1024];

  snprintf(outbuffer,sizeof(outbuffer),"cddb hello %s %s %s %s\n",hello->hello_user,hello->hello_hostname,hello->hello_program,hello->hello_version);

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_message[0]!='2')
  {
    return 0;
  }

  return 1;
}

/**
 * Set the CDDB protocol level for a CDDBP session to the protocol level 
 * supported by this library.  To be done after use of 'cddb_handshake'.  
 * This is required for some operations to function properly.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @return 1 on success, 0 on failure, and CDSOCKET_ERROR 
 *         on socket failure.  
 */ 
int cddb_proto(cdsock_t sock)
{
  char outbuffer[256];

  snprintf(outbuffer,sizeof(outbuffer),"proto %d\n",CDDB_PROTOCOL_LEVEL);

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if((cddb_message[0]!='2')&&(cddb_message[0]!='5'&&cddb_message[1]!='0'&&cddb_message[2]!='2'))
  {
    return 0;
  }

  return 1;
}

/* Generate the CDDB request string.  */
static int cddb_generate_http_request(char *outbuffer,const char *cmd,char *http_string,int outbufferlen)
{
  int index=0;
  char *reqstring;

  if((reqstring=strchr(http_string,'?'))==NULL)
    return -1;

  index=reqstring-http_string;
  http_string[index]='\0';
  reqstring++;

  snprintf(outbuffer,outbufferlen,"%s?cmd=%s&%s\n",http_string,cmd,reqstring);
  http_string[index]='?';

  return 0;
}

/* Skip HTTP header */
static int cddb_skip_http_header(cdsock_t sock)
{
  char inchar;
  int len;

  do
  {
    len=0;
    do
    {
      if(recv(sock,&inchar,1,0)!=1)
	return CDSOCKET_ERROR;
      len++;
    } while(inchar!='\n');
  } while(len>2);

  return 0;
}

/* Process a CDDB query string.  */
static int cddb_proc_query_string(char *line,struct query_list_entry* entry)
{
  char *start,*end;

  /* Advance to category.  */
  end=strchr(line,' ');
  if(end==NULL)
    return -1;
  *end='\0';
  entry->list_category=cddb_category_value(line);

  /* Advance to discid.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';
  entry->list_id=strtoul(start,NULL,16); 

  /* Advance to Artist name / Album title.  */
  start=end+1;
  end=strstr(start," / ");
  if(end==NULL)
  {
    /* There is no album title.  */
    strncpy(entry->list_artist,start,sizeof(entry->list_artist));
    strncpy(entry->list_title,start,sizeof(entry->list_title));
  }
  else
  {
    *end='\0';
    strncpy(entry->list_artist,start,sizeof(entry->list_artist));
    strncpy(entry->list_title,end+3,sizeof(entry->list_title));
  }

  return 0;
}

/**
 * Query CDDB for an entry corresponding to a specified CDDB id.  
 * The query provides a list of one or more exact and/or inexact matches
 * for the CDDB id specified.  After selecting an item from the list, the
 * corresponding CDDB entry can be retrieved with a subsequent call to 'cddb_read'.  
 * @param querystr a character string, specifying the CDDB id and disk 
 *        track info required for a CDDB query, obtained from 'cddb_query_string'.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @param mode an integer indicating CDDB server mode, either CDDBP or HTTP.  
 * @param query a cddb_query structure to be filled with CDDB query info.  
 * @param http_string a variable argument only required when using HTTP.  
 *        This is a character array filled with the CDDB handshake string
 *        obtained from 'cddb_connect'.  
 * @return 1 on query success, 0 on query failure, and CDSOCKET_ERROR 
 *         on socket failure.  
 */
int cddb_query(const char* querystr,cdsock_t sock,int mode,struct cddb_query *query,...)
{
  int index;
  char outbuffer[1024],outtemp[1024],inbuffer[256],*http_string;

  memset(query,0,sizeof(*query));

  if(mode==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,query);

    http_string=va_arg(arglist,char *);
    snprintf(outtemp,sizeof(outtemp),"cddb+query+%s",querystr);

    /* Replace any spaces with '+'.  */
    for(index=0;index<sizeof(outtemp)&&outtemp[index]!='\0';index++)
      if(outtemp[index]==' ') outtemp[index]='+';

    cddb_generate_http_request(outbuffer,outtemp,http_string,sizeof(outbuffer));

    va_end(arglist);
  }
  else
  {
    snprintf(outbuffer,sizeof(outbuffer),"cddb query %s\n",querystr);
  }

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(mode==CDDB_MODE_HTTP)
    cddb_skip_http_header(sock);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }
   
  if(cddb_message[0]!='2')
  {
    query->query_match=QUERY_NOMATCH;
    return 0;
  }
   
  /* First check for single exact match - return code 200.  */
  if(cddb_message[1]=='0')
  {
    if(cddb_message[2]!='0')
    {
      query->query_match=QUERY_NOMATCH;
      return 1;
    }

    query->query_match=QUERY_EXACT;
    query->query_matches=1;

    /* Copy message to inbuffer for processing.  */
    strncpy(inbuffer,cddb_message,sizeof(inbuffer));

    if(cddb_proc_query_string(&inbuffer[4],&query->query_list[0])==-1)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Error processing server reply");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }
  else if(cddb_message[1]==1)
  {
    /* Either multiple exact matches or inexact matches.  */
    if(cddb_message[2]==0)
      query->query_match=QUERY_EXACT;
    else if(cddb_message[2]==1)
      query->query_match=QUERY_INEXACT;
    else
    {
      query->query_match = QUERY_NOMATCH;
      return 1;
    }

    query->query_matches=0;
    if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }

    while(inbuffer[0]!='.')
    {
      /* Skip all tracks in excess of MAX_TRACKS.  */
      if(query->query_matches<MAX_TRACKS)
      {
        if(cddb_proc_query_string(inbuffer,&query->query_list[query->query_matches])==-1)
        {
          snprintf(cddb_message,sizeof(cddb_message),"Error processing server reply");
          cddb_close(sock);
          return CDSOCKET_ERROR;
	}
        query->query_matches++;
      }

      if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
      {
        snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
        cddb_close(sock);
        return CDSOCKET_ERROR;
      }
    }
  }
  else
  {
    query->query_match=QUERY_NOMATCH;
  }

  return 1;
}

/* 
 * Copy from data read from CDDB server from one buffer to the other, 
 * processing any excaped characters.  
 * @return number of bytes copied (does not include '\0')
 */
static int cddb_read_copy(char* dest,const char* src,int n)
{
  int index=0,total=0;
  char c;

  do
  {
    c=src[index++];
    if(c=='\\')
    {
      switch(src[index])
      {
      case 'n':
	c='\n';	index++;
	break;
      case 't':
	c='\t';	index++;
	break;
      case '\\':
	index++;
	break;
      }
    }
    dest[total]=c;
    if(c!='\0') total++;
  } while(c!='\0'&&total<n);
  return total;
}

/* Process a line read from CDDB database.  */
static int cddb_proc_read_string(char *line,struct disc_data *data,struct __disc_data *__data)
{
  int index=0;
  char *key,*value;

  /*Skip white space.  */
  while(isspace(line[index])) index++;

  if(line[index]=='#')
  {
    if(strstr(line,"Revision:")!=NULL)
    {
      value=strchr(line,':');
      while(!isdigit(value[index])&&value[index]!='\0')
        index++;
      data->data_revision=strtol(value,NULL,10);
    }
  }
  else
  {
    value=strchr(line,'=');
    if(value==NULL)
      return 0;

    key=line;
    *value='\0';
    value++;

    /* We ignore DISCID and PLAYORDER.  */
    if(strcmp(key,"DTITLE")==0)
    {
      /* Concatenate all DTITLE entries.  cddb_read will parse.  */
      __data->dtitle_len+=cddb_read_copy(&__data->dtitle[__data->dtitle_len],value,sizeof(__data->dtitle)-__data->dtitle_len-1);
    }
    else if(strcmp(key,"DYEAR")==0)
    {
      strncpy(data->data_year,value,4);
      data->data_year[4]='\0';
    }
    else if(strcmp(key,"DGENRE")==0)
    {
      /* Length minus one to ensure that when the whole buffer is filled, the last item is the terminator.  */
      __data->genre_len+=cddb_read_copy(&data->data_genre[__data->genre_len],value,sizeof(data->data_genre)-__data->genre_len-1);
    }
    else if(strncmp(key,"TTITLE",6)==0)
    {
      /* Get track number.  */
      index=strtol(key+6,NULL,10);
      if(index>=0&&index<MAX_TRACKS)
      {
        /* Concatenate all DTITLE entries.  cddb_read will parse.  */
        __data->track[index].ttitle_len+=cddb_read_copy(&__data->track[index].ttitle[__data->track[index].ttitle_len],value,sizeof(__data->track[index].ttitle)-__data->track[index].ttitle_len-1);

        /* Update the number of tracks, with highest known track value.  */
	if(__data->track_total<index) __data->track_total=index;
      }
    }
    else if(strcmp(key,"EXTD")==0)
    {
      /* Length minus one to ensure that when the whole buffer is filled, the last item is the terminator.  */
      __data->ext_len+=cddb_read_copy(&data->data_extended[__data->ext_len],value,sizeof(data->data_extended)-__data->ext_len-1);
    }
    else if(strncmp(key,"EXTT",4)==0)
    {
      /* Get track number.  */
      index=strtol(key+4,NULL,10);
      if(index>=0&&index<MAX_TRACKS)
      {
        /* Length minus one to ensure that when the whole buffer is filled, the last item is the terminator.  */
        __data->track[index].ext_len+=cddb_read_copy(&data->data_track[index].track_extended[__data->track[index].ext_len],value,sizeof(data->data_track[index].track_extended)-__data->track[index].ext_len-1);
      }
    }
  }

  return 0;
}

/* Process parse artist names and song titles.  */
static void cddb_proc_read_data(struct disc_data *data,struct __disc_data *__data)
{
  int index;
  char *artist,*title;

  /* Get album artist name and title.  */
  artist=__data->dtitle;
  title=strstr(artist," / ");
  if(title==NULL)
  {
    /* Minus one to ensure that if the entire buffer is filled, the last item is '\0'.  */
    strncpy(data->data_artist,artist,sizeof(data->data_artist)-1);
    strncpy(data->data_title,artist,sizeof(data->data_title)-1);
  }
  else
  {
    *title='\0';
    strncpy(data->data_artist,artist,sizeof(data->data_artist)-1);
    strncpy(data->data_title,title+3,sizeof(data->data_title)-1);
  }
  
  for(index=0;index<=__data->track_total;index++)
  {
    artist=__data->track[index].ttitle;
    title=strstr(artist," / ");
    if(title==NULL)
    {
      strncpy(data->data_track[index].track_title,artist,sizeof(data->data_track[index].track_title)-1);
      data->data_track[index].track_artist[0]='\0';
    }
    else
    {
      *title='\0';
      strncpy(data->data_track[index].track_artist,artist,sizeof(data->data_track[index].track_artist)-1);
      strncpy(data->data_track[index].track_title,title+3,sizeof(data->data_track[index].track_title)-1);
    }
  }

  /* Set the total number of track entries in list.  */
  data->data_total_tracks=__data->track_total+1;
}

/**
 * Read CDDB data for a specified CDDB entry.  
 * @param category an integer specifying the category for the disc whose 
 *        data is to be retrieved.  
 * @param discid an unsigned long specifying the id for the disc whose data
 *        is to be retrieved.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @param mode an integer indicating CDDB server mode, either CDDBP or HTTP.  
 * @param data a disc_data structure to be filled with the retrieved CDDB data.  
 * @param http_string a variable argument only required when using HTTP.  
 *        This is a character array filled with the CDDB handshake string
 *        obtained from 'cddb_connect'.  
 * @return 1 on read success, 0 on read failure, and CDSOCKET_ERROR 
 *         on socket failure.  
 */
int cddb_read(int category,unsigned long discid,cdsock_t sock,int mode,struct disc_data *data,...)
{
  char outbuffer[1024],outtemp[1024],inbuffer[256],*http_string;
  struct __disc_data __data;

  memset(&__data,0,sizeof(__data));
  memset(data,0,sizeof(*data));

  if(mode==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,data);

    http_string=va_arg(arglist,char *);
    snprintf(outtemp,sizeof(outtemp),"cddb+read+%s+%08lx",cddb_category(category,inbuffer,sizeof(inbuffer)),discid);
    cddb_generate_http_request(outbuffer,outtemp,http_string,sizeof(outbuffer));

    va_endlist(arglist);
  }
  else
  {
    snprintf(outbuffer,sizeof(outbuffer),"cddb read %s %08lx\n",cddb_category(category,inbuffer,sizeof(inbuffer)),discid);
  }

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(mode==CDDB_MODE_HTTP)
    cddb_skip_http_header(sock);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_message[0]!=2&&cddb_message[1]!=1)
    return 0;

  data->data_id=discid;
  data->data_category=category;

  if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  while(inbuffer[0]!='.')
  {
    cddb_proc_read_string(inbuffer,data,&__data);

    if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }

  cddb_proc_read_data(data,&__data);

  return 1;
}

/* Process a single line in the sites list.  */
static int cddb_proc_sites_line(char *line,struct cddb_host *host)
{
  int index=0;
  char *start,*end;

  /* Extract site address.  */
  end=strchr(line,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  strncpy(host->host_server.server_name,line,sizeof(host->host_server.server_name));

  /* Extract protocol.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  if(strncasecmp(start,"cddbp",5)==0)
    host->host_protocol=CDDB_MODE_CDDBP;
  else if(strncasecmp(start,"http",4)==0)
    host->host_protocol=CDDB_MODE_HTTP;
  else
    return -1;

  /* Extract port.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  host->host_server.server_port=strtol(start,NULL,10);

  /* Extract addressing.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  if(strcmp(start,"-")==0)
    host->host_addressing[0]='\0';
  else
    strncpy(host->host_addressing,start,sizeof(host->host_addressing));

  /* Extract latitude.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  strncpy(host->host_latitude,start,sizeof(host->host_latitude));

  /* Extract longitude.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  strncpy(host->host_longitude,start,sizeof(host->host_longitude));

  /* Extract description.  */
  start=end+1;
  strncpy(host->host_description,start,sizeof(host->host_description));

  return 0;
}

/** 
 * Read the list of CDDB server sites.   
 * @param sock handle to the socket connected to the CDDB server.  
 * @param mode an integer indicating CDDB server mode, either CDDBP or HTTP.  
 * @param list a cddb_serverlist structure to be filled with the retrieved server data.  
 * @param http_string a variable argument only required when using HTTP.  
 *        This is a character array filled with the CDDB handshake string
 *        obtained from 'cddb_connect'.  
 * @return 1 on read success, 0 on read failure, and CDSOCKET_ERROR 
 *         on socket failure.  
 */
int cddb_sites(cdsock_t sock,int mode,struct cddb_serverlist *list,...)
{
  char outbuffer[1024],inbuffer[256],*http_string;

  memset(list,0,sizeof(*list));

  if(mode==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,list);
    http_string=va_arg(arglist,char *);
    cddb_generate_http_request(outbuffer,"sites",http_string,sizeof(outbuffer));
    va_end(arglist);
  }
  else
    strcpy(outbuffer,"sites\n");

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(mode==CDDB_MODE_HTTP)
    cddb_skip_http_header(sock);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_message[0]!=2)
    return 0;

  list->list_len=0;
  if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  while(inbuffer[0]!='.')
  {
    if(cddb_sites_process_line(inbuffer,&list->list_host[list->list_len])!=-1)
      list->list_len++;
  
    if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }

  return 1;
}

/**
 * Terminate the connection to the CDDB server.  If the server mode
 * is CDDBP, the quit command will be issued and the socket will be closed.  
 * If hte server mode is HTTP the socket will simply be closed.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @param mode an integer indicating CDDB server mode, either CDDBP or HTTP.  
 * @return 1 on read success, 0 on read failure, and CDSOCKET_ERROR 
 *         on socket failure.  
 */
int cddb_quit(cdsock_t sock,int mode)
{
  char outbuffer[]="quit\n";

  if(mode==CDDB_MODE_CDDBP)
  {
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }

    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }

  cddb_close(sock);
  return 0;
}

/* Read a single line from a file.  */
static int cddb_read_file_line(FILE* fd,char *inbuffer,int len)
{
  int index;
  char inchar;

  len--;  /* Make sure their is always a null terminator.  */
  index=0;

  inchar=fgetc(fd);
  while(inchar!=EOF&&inchar!='\n'&&index<len)
  {
    if(inchar!='\r')
      inbuffer[index++]=inchar;
    inchar=fgetc(fd);
  }

  inbuffer[index]='\0';
  return index;
}

/**
 * Read CDDB data from a local directory.  
 * @param path a string containing the path to the directory containig
 *        the local CDDB data files.  
 * @param discid an unsigned long specifying the id of the CD whose CDDB
 *        data is to be read.  
 * @param data a disc_data structure to be filled with the read CDDB data.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_read_local(const char *path,unsigned long discid,struct disc_data *data)
{
  int len;
  char file[PATH_MAX],inbuffer[256];
  struct __disc_data __data;
  FILE* fd;

  memset(&__data,0,sizeof(__data));
  memset(data,0,sizeof(*data));

  len=strlen(path);
  if(path[len-1]==PATHSEP)
    snprintf(file,sizeof(file),"%s%08lx",path,discid);
  else
    snprintf(file,sizeof(file),"%s%c%08lx",path,PATHSEP,discid);

  if((fd=fopen(file,"r"))==NULL)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Could not open file %s",file);
    return -1;
  }

  /* Read lines and process.  */
  data->data_id=discid;
  data->data_category=CDDB_UNKNOWN;

  cddb_read_file_line(fd,inbuffer,sizeof(inbuffer));
  while(!feof(fd)&&!ferror(fd)&&inbuffer[0]!='.')
  {
    cddb_proc_read_string(inbuffer,data,&__data);
    cddb_read_file_line(fd,inbuffer,sizeof(inbuffer));
  }

  cddb_proc_read_data(data,&__data);

  /* Return -1 if error was encountered.  */
  if(ferror(fd))
  {
    snprintf(cddb_message,sizeof(cddb_message),"Error reading file %s",file);
    fclose(fd);
    return -1;
  }

  fclose(fd);

  /* Return 0 if EOF or '.' was found.  */
  return 0;
}

/* Write a line to file.  */
static int cddb_write_file_line(FILE* fd,const char *key,const char* value)
{
  int count=0,total=0;
  char outchar,special='\0';

  fprintf(fd,"%s",key);
  count=strlen(key);

  outchar='=';
  while(outchar!='\0')
  {
    /* Character 256 should be the new line.  */
    if(count>=255)
    {
      fputc('\n',fd);
      total+=count+1;
      fprintf(fd,"%s=",key);
      count=strlen(key)+1;
    }

    switch(outchar)
    {
    case '\n':
      outchar='\\';
      special='n';
      break;
    case '\t':
      outchar='\\';
      special='t';
      break;
    case '\\':
      /* If special is already '\\', we are midway through '\\' write.  */
      if(special!='\\')
      {
        outchar='\\';
        special='\\';
      }
      break;
    }

    fputc(outchar,fd);
    count++;

    if(special!='\0')
    {
      outchar=special;
      special='\0';
    }
    else
      outchar=*value++;
  }

  /* Replace '\0' with '\n'.  'count' is <= 255,  */
  fputc('\n',fd);
  count++;

  return total+count;
}

/*  Write data to file.  */
static int cddb_write_local_file(FILE* fd,const struct cddb_hello *hello,const struct disc_info *info,const struct disc_data *data,const char *comment)
{
  int len,index;
  char key[256],outbuffer[EXTENDED_DATA_SIZE];

  fprintf(fd,"# xmcd\n#\n# Track frame offset:\n");
  for(index=0;index<info->disc_total_tracks;index++)
    fprintf(fd,"#        %d\n",info->disc_track[index].track_pos.frames);
  fprintf(fd,"#\n# Disc length: %d seconds\n",(info->disc_length.minutes*60)+info->disc_length.seconds);

  if(comment!=NULL)
    fprintf(fd,"#\n# Revision: %d\nSubmitted via: %s %s %s\n#\n",data->data_revision,hello->hello_program,hello->hello_version,comment);
  else
    fprintf(fd,"#\n# Revision: %d\nSubmitted via: %s %s\n#\n",data->data_revision,hello->hello_program,hello->hello_version);

  fprintf(fd,"DISCID=%08lx\n",data->data_id);
  if(data->data_title[0]=='\0')
    cddb_write_file_line(fd,"DTITLE",data->data_artist);
  else
  {
    snprintf(outbuffer,sizeof(outbuffer),"%s / %s",data->data_artist,data->data_title);
    cddb_write_file_line(fd,"DTITLE",outbuffer);
  }

  cddb_write_file_line(fd,"DYEAR",data->data_year);
  cddb_write_file_line(fd,"DGENRE",data->data_genre);

  for(index=0;index<data->data_total_tracks;index++)
  {
    snprintf(key,sizeof(key),"TTITLE%d",index);
    if(data->data_track[index].track_artist=='\0')
      cddb_write_file_line(fd,key,data->data_track[index].track_title);
    else
    {
      snprintf(outbuffer,sizeof(outbuffer),"%s / %s",data->data_track[index].track_artist,data->data_track[index].track_title);
      cddb_write_file_line(fd,key,outbuffer);
    }
  }

  cddb_write_file_line(fd,"EXTD",data->data_extended);

  for(index=0;index<data->data_total_tracks;index++)
  {
    snprintf(key,sizeof(key),"EXTT%d",index);
    cddb_write_file_line(fd,key,data->data_track[index].track_extended);
  }

  fprintf(fd,"PLAYORDER=\n.\n");

  return (ferror(fd))?-1:0;
}

/**
 * Write CDDB data to a local directory.  
 * @param path a string containing the path to the directory containig
 *        the local CDDB data files.  
 * @param hello a cddb_hello structure containing the name and version 
 *        numberof the program that is writing the CDDB data.  Only the
 *        'hello_program' and 'hello_version' fields need to be filled.  
 *        The 'hello_user' and 'hello_hostname' fields will be ignored.  
 * @param info a disc_info structure containing the frame offsets and total 
 *        length for the CD whose CDDB data is to be written.  Obtained from
 *        the 'cd_stat' function.  
 * @param data a disc_data structure containing the CDDB data to be written.  
 * @param comment a character string specifying a comment to be added to the 
 *        CDDB data file.  This parameter is optional, and may be NULL.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_write_local(const char *path,const struct cddb_hello *hello,const struct disc_info *info,const struct disc_data *data,const char *comment)
{
  int len,index;
  char file[PATH_MAX],key[256],outbuffer[EXTENDED_DATA_SIZE];
  FILE* fd;

  len=strlen(path);
  if(path[len-1]==PATHSEP)
    snprintf(file,sizeof(file),"%s%08lx",path,data->data_id);
  else
    snprintf(file,sizeof(file),"%s%c%08lx",path,PATHSEP,data->data_id);

  /* Binary to prevent inclusion of carriage return with WIN32.  */
  if((fd=fopen(file,"wb"))==NULL)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Could not open file %s for writing",file);
    return -1;
  }

  if(cddb_write_local_file(fd,hello,info,data,comment)<0)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Error writing file %s",file);
    fclose(fd);
    return -1;
  }

  fclose(fd);

  return 0;
}

/**
 * Erase CDDB data from local directory.  
 * @param path a string containing the path to the directory containig
 *        the local CDDB data files.  
 * @param discid an unsigned long specifying the id of the CD whose CDDB
 *        data is to be erased.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_erase_local(const char *path,unsigned long discid)
{
  int len;
  char file[PATH_MAX];

  len=strlen(path);
  if(path[len-1]==PATHSEP)
    snprintf(file,sizeof(file),"%s%08lx",path,discid);
  else
    snprintf(file,sizeof(file),"%s%c%08lx",path,PATHSEP,discid);

  if(unlink(file)<0)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Could not remove file %s",file);
    return -1;
  }

  return 0;
}

/**
 * Submit CDDB data to a CDDB server.  Data can be submitted via HTTP or
 * SMTP.  Submissions can only be made with the US_ASCII and
 * ISO-8859-1 characeter sets.  If 'CDDBTESTSUBMIT' is defined, the 
 * data will be sent to the specified CDDB server in test mode when doing 
 * an HTTP submit.  
 * @param host a cddb_host structure specifying the CDDB 
 *        server with which to connect.  
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value 
 *        should be NULL.  
 * @param hello a cddb_hello structure containing the name and version 
 *        numberof the program that is writing the CDDB data.  For HTTP
 *        submissions only the 'hello_program' and 'hello_version' fields 
 *        need to be filled.  The 'hello_user' and 'hello_hostname' fields will 
 *        be ignored.  For SMTP submissions the 'hello_program', hello_version',
 *        and 'hello_hostname' fields will have to be filled.  
 * @param info a disc_info structure containing the frame offsets and total 
 *        length for the CD whose CDDB data is to be written.  Obtained from
 *        the 'cd_stat' function.  
 * @param data a disc_data structure containing the CDDB data to be written.  
 * @param comment a character string specifying a comment to be added to the 
 * @param email_address a character string specifying the user's email address.  
 * @param submit_address a character string specifying the submission email address.  
 *        Typically 'freedb-submit@freedb.org' for actual submissions and 
 *        'test-submit@freedb.org' for test submissions.  
 * @param mime_type an integer specifying that the MIME "quoted-printable" scheme 
 *        is to be used.  Use this scheme to submit entries containing 8-bit 
 *        characters (for accents such as umlaut, or other extended characters).  
 *        Set to 1 to enable, 0 to disable.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_submit(const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello *hello,const struct disc_info *info,const struct disc_data *data,const char *comment,const char *email_address,...)
{
  int index,mime_type;
  long length;
  char outbuffer[512],inbuffer[256],*submit_address;
  cdsock_t sock;
  FILE *fd;

  /* Generate data in temp file.  */
  if((fd=tmpfile())==NULL)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Could not create temporary file");
    return -1;
  }

  /* Write data.  */
  if(cddb_write_local_file(fd,hello,info,data,comment)<0)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Error generating temporary data file");
    fclose(fd);
    return -1;
  }

  /* Calculate length and reset file position.  */
  length=ftell(fd);
  fseek(fd,0,SEEK_SET);
  length-=ftell(fd);
  if(ferror(fd))
  {
    snprintf(cddb_message,sizeof(cddb_message),"Error calculating data legth");
    fclose(fd);
    return -1;
  }

  /* Connect to server.  */
  if(proxy!=NULL)
  {
    if((sock=cddb_connect_server(proxy))==INVALID_CDSOCKET)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Failed to connect with proxy server");
      fclose(fd);
      return -1;
    }
  }
  else
  {
    if((sock=cddb_connect_server(&host->host_server))==INVALID_CDSOCKET)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Failed to connect with %s",host->host_server.server_name);
      fclose(fd);
      return -1;
    }
  }

  if(host->host_protocol==CDDB_SUBMIT_SMTP)
  {
    /* Send SMTP header.  */
    va_list arglist;
    va_start(arglist,email_address);
    submit_address=va_arg(arglist,char *);
    mime_type=va_arg(arglist,int);

    /* Read the opening message.  */
    if(cddb_read_line(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(inbuffer,"220",3)!=0)
    {
      strncpy(cddb_message,inbuffer,sizeof(cddb_message));
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send HELO.  */
    snprintf(outbuffer,sizeof(outbuffer),"HELO %s\r\n",hello->hello_hostname);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"250",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send FROM.  */
    snprintf(outbuffer,sizeof(outbuffer),"MAIL FROM: <%s>\r\n",email_address);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"250",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send RCPT.  */
    snprintf(outbuffer,sizeof(outbuffer),"RCPT TO: <%s>\r\n",submit_address);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"250",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send DATA.  */
    snprintf(outbuffer,sizeof(outbuffer),"DATA\r\n");
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"354",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send our info.  */
    snprintf(outbuffer,sizeof(outbuffer),"From: %s\r\n",email_address);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"To: %s\r\n",submit_address);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"X-Cddbd-Note: Sent by %s - Questions: contact %s maintainer\n",hello->hello_program,hello->hello_program);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"Subject: cddb %s %08lx\r\n",cddb_category(data->data_category,inbuffer,sizeof(inbuffer)),data->data_id);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }
 
    if (mime_type)
    {
      snprintf(outbuffer,sizeof(outbuffer),"MIME-Version: 1.0\r\n"
                                           "Content-Type: text/plain; charset=ISO-8859-1\r\n"
                                           "Content-Transfer-Encoding: quoted-printable\r\n");
      if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
      {
        snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
        cddb_close(sock);
        fclose(fd);
        return -1;
      }
    }

    /* Start body.  */
    if(send(sock,"\r\n",2,0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    va_end(arglist);
  }
  else
  {
    /* Send HTTP header.  */
    if (proxy != NULL)
      snprintf(outbuffer,sizeof(outbuffer),"POST http://%s:%d%s HTTP/1.0\n",host->host_server.server_name,host->host_server.server_port,host->host_addressing);
    else
      snprintf(outbuffer,sizeof(outbuffer),"POST %s HTTP/1.0\n",host->host_addressing);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"Category: %s\n",cddb_category(data->data_category,inbuffer,sizeof(inbuffer)));
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"Discid: %08lx\n",data->data_id);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"User-Email: %s\n",email_address);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

#ifdef CDDBTESTSUBMIT
    snprintf(outbuffer,sizeof(outbuffer),"Submit-Mode: %s\n","test");
#else
    snprintf(outbuffer,sizeof(outbuffer),"Submit-Mode: %s\n","submit");
#endif
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"X-Cddbd-Note: Sent by %s - Questions: contact %s maintainer\n",hello->hello_program,hello->hello_program);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"Content-Length: %d\n\n",length);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }
  }

  /* Send cd data.  */
  while(!feof(fd))
  {
    fgets(outbuffer,sizeof(outbuffer),fd);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }
  }

  if(host->host_protocol==CDDB_SUBMIT_SMTP)
  {
    if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"250",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send QUIT.  */
    snprintf(outbuffer,sizeof(outbuffer),"QUIT\r\n");
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"221",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    strncpy(cddb_message,"OK, submission has been sent",sizeof(cddb_message));
  }
  else
  {
    cddb_skip_http_header(sock);

    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }
  }

  cddb_close(sock);
  fclose(fd);

  return 0;
}

/**
 * Query CDDB for an entry corresponding to a specified CDDB id 
 * via HTTP.  Simply calls the 'cddb_connect', 'cddb_query', and 
 * 'cddb_quit' functions, in that order.  Provided to simplify use 
 * of HTTP with CDDB.  
 * @param querystr a character string, specifying the CDDB id and disk 
 *        track info required for a CDDB query, obtained from 'cddb_query_string'.  
 * @param host a cddb_host structure specifying the CDDB 
 *        server with which to connect.  
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value 
 *        should be NULL.  
 * @param hello a cddb_hello structure specifying the name and version 
 *        of the application connecting to the CDDB server.  
 * @param query a cddb_query structure to be filled with CDDB query info.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_http_query(const char *querystr,const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello* hello,struct cddb_query *query)
{
  char http_string[1024];
  cdsock_t sock;

  /* Make sure mode is correct.  */
  if(host->host_protocol!=CDDB_MODE_HTTP)
    return -1;

  /* Connect.  */
  if((sock=cddb_connect(host,proxy,hello,http_string,sizeof(http_string)))==INVALID_CDSOCKET)
    return -1;

  /* Query.  */
  if(cddb_query(querystr,sock,host->host_protocol,query,http_string)<1)
  {
    cddb_close(sock);
    return -1;
  }

  cddb_quit(sock,host->host_protocol);

  return 0;
}

/**
 * Read CDDB data for a specified CDDB entry via HTTP.   Simply calls 
 * the 'cddb_connect', 'cddb_read', and 'cddb_quit' functions, in that 
 * order.  Provided to simplify use of HTTP with CDDB.  
 * @param category an integer specifying the category for the disc whose 
 *        data is to be retrieved.  
 * @param discid an unsigned long specifying the id for the disc whose data
 *        is to be retrieved.  
 * @param host a cddb_host structure specifying the CDDB 
 *        server with which to connect.  
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value 
 *        should be NULL.  
 * @param hello a cddb_hello structure specifying the name and version 
 *        of the application connecting to the CDDB server.  
 * @param data a disc_data structure to be filled with the retrieved CDDB data.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_http_read(int category,unsigned long discid,const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello* hello,struct disc_data *data)
{
  char http_string[1024];
  cdsock_t sock;

  /* Make sure mode is correct.  */
  if(host->host_protocol!=CDDB_MODE_HTTP)
    return -1;

  /* Connect.  */
  if((sock=cddb_connect(host,proxy,hello,http_string,sizeof(http_string)))==INVALID_CDSOCKET)
    return -1;

  /* Read.  */
  if(cddb_read(category,discid,sock,host->host_protocol,data,http_string)<1)
  {
    cddb_close(sock);
    return -1;
  }

  cddb_quit(sock,host->host_protocol);

  return 0;
}

/**
 * Retrieve CDDB server list via http.  Simply calls
 * the 'cddb_connect', 'cddb_sites', and 'cddb_quit' functions, in that 
 * order.  Provided to simplify use of HTTP with CDDB.  
 * @param host a cddb_host structure specifying the CDDB 
 *        server with which to connect.  
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value 
 *        should be NULL.  
 * @param hello a cddb_hello structure specifying the name and version 
 *        of the application connecting to the CDDB server.  
 * @param list a cddb_serverlist structure to be filled with the retrieved server data.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_http_sites(const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello* hello,struct cddb_serverlist *list)
{
  char http_string[1024];
  cdsock_t sock;

  /* Make sure mode is correct.  */
  if(host->host_protocol!=CDDB_MODE_HTTP)
    return -1;

  /* Connect.  */
  if((sock=cddb_connect(host,proxy,hello,http_string,sizeof(http_string)))==INVALID_CDSOCKET)
    return -1;

  /* Read.  */
  if(cddb_sites(sock,host->host_protocol,list,http_string)<1)
  {
    cddb_close(sock);
    return -1;
  }

  cddb_quit(sock,host->host_protocol);

  return 0;
}

/**
 * Fully initiate a connection with a CDDB server.  Simply calls 
 * the 'cddb_connect', 'cddb_handshake', and 'cddb_proto' functions,
 * in that order.  Provided to simplify use of CDDBP with CDDB (but
 * can also be used with HTTP; equivalent to 'cddb_connect' when used
 * with HTTP).  With CDDBP, calling the "cddb_connect', "cddb_handshake', 
 * and 'cddb_proto' functions separately allows the calling program to 
 * analyze the 'cddb_message' string containing the CDDB server response 
 * for each function individually.  
 * @param host a cddb_host structure specifying the CDDB 
 *        server with which to connect.  
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value 
 *        should be NULL.  
 * @param hello a cddb_hello structure specifying the name and version 
 *        of the application connecting to the CDDB server.  
 * @param http_string a variable argument only required when using HTTP.  
 *        This is a character array to be filled by the function with a 
 *        CDDB handshake string.  This string will be required for further
 *        HTTP queries.  Note that the string for CDDB queries differs from
 *        the string for CDDB submissions.  When using CDDB with HTTP, separate
 *        connections for CDDB queries and submissions are required.  
 * @param https_string_len a variable argument only required when using HTTP.  
 *        This is an integer specifying the size of the http_string character array.  
 * @return handle to a connected socket on success, 
 *         INVALID_CDSOCKET on failure.  
 */
cdsock_t cddb_initiate(const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello *hello,...)
{
  cdsock_t sock;
  int http_string_len;
  char *http_string;

  if(host->host_protocol==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,hello);
    http_string=va_arg(arglist,char *);
    http_string_len=va_arg(arglist,int);

    if((sock=cddb_connect(host,proxy,hello,http_string,http_string_len))==INVALID_CDSOCKET)
      return INVALID_CDSOCKET;

    va_end(arglist);
  }
  else
  {
    if((sock=cddb_connect(host,proxy))==INVALID_CDSOCKET)
      return INVALID_CDSOCKET;

    if(cddb_handshake(sock,hello)<1)
    {
      cddb_close(sock);
      return INVALID_CDSOCKET;
    }

    if(cddb_proto(sock)<1)
    {
      cddb_close(sock);
      return INVALID_CDSOCKET;
    }
  }

  return sock;
}

/**
 * Complete a full CDDB transaction for retrieving the data from a specified 
 * CD.  If multiple data entries are available, the first one will be 
 * chosen.  Provided as a convenience.  
 * @param cd_desc the handle to the cd device containing CD for which to 
 *        obtain CDDB data.  
 * @param host a cddb_host structure specifying the CDDB 
 *        server with which to connect.  
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value 
 *        should be NULL.  
 * @param hello a cddb_hello structure specifying the name and version 
 *        of the application connecting to the CDDB server.  
 * @param data a disc_data structure to be filled with the retrieved CDDB data.  
 * @return 1 if an entry is found, 0 if no entry is found, and -1 if an 
 *         error is encountered.  
 */
int cddb_read_data(cddesc_t cd_desc,const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello *hello,struct disc_data *data)
{
  char inbuffer[256],http_string[1024];
  cdsock_t sock;
  struct cddb_query query;

  /* Get Query string.  */
  if(cddb_query_string(cd_desc,inbuffer,sizeof(inbuffer))==NULL)
    return -1;

  /* Connect.  */
  if((sock=cddb_initiate(host,proxy,hello,http_string,sizeof(http_string)))==INVALID_CDSOCKET)
    return -1;

  /* Query.  */
  if(cddb_query(inbuffer,sock,host->host_protocol,&query,http_string)<1)
  {
    cddb_close(sock);
    return -1;
  }

  /* Check for match.  */
  if(query.query_match==QUERY_NOMATCH||query.query_matches==0)
  {
    cddb_close(sock);
    return 0;
  }

  /* Grab first match in list.  */
  if(cddb_read(query.query_list[0].list_category,query.query_list[0].list_id,sock,host->host_protocol,data,http_string)<1)
  {
    cddb_close(sock);
    return -1;
  }

  cddb_quit(sock,host->host_protocol);

  return 1;
}

/**
 * Complete a full CDDB transaction for a retrieving a list of CDDB server
 * sites.  Provided as a convenience.  
 * @param host a cddb_host structure specifying the CDDB 
 *        server with which to connect.  
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value 
 *        should be NULL.  
 * @param hello a cddb_hello structure specifying the name and version 
 *        of the application connecting to the CDDB server.  
 * @param list a cddb_serverlist structure to be filled with the retrieved server data.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_read_sites(const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello *hello,struct cddb_serverlist *list)
{
  char http_string[1024];
  cdsock_t sock;

  /* Connect.  */
  if((sock=cddb_initiate(host,proxy,hello,http_string,sizeof(http_string)))==INVALID_CDSOCKET)
    return -1;

  /* Get server list.  */
  if(cddb_sites(sock,host->host_protocol,list,http_string)<1)
  {
    cddb_close(sock);
    return -1;
  }

  cddb_quit(sock,host->host_protocol);

  return 0;
}
