/*
This is part of the audio CD player library
Copyright (C)1998-99 Tony Arcieri <bascule@inferno.tusculum.edu>
Copyright (C)2001 Dustin Graves <dgraves@computer.org>

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with this library; if not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA  02111-1307, USA.
*/

#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <string.h>
#include <errno.h>
#include <time.h>

#ifndef WIN32
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pwd.h>
#else
#include <winsock2.h>
#include <windows.h>

#define strcasecmp  _stricmp
#define strncasecmp _strnicmp
#define snprintf _snprintf
#endif

#ifndef INADDR_NONE
#define INADDR_NONE 0xFFFFFFFF
#endif

#include "cdlyte.h"

/* Some procedures differ on Windows.  */
#ifndef WIN32
#define cddb_close close
#else
#define cddb_close closesocket
#endif

#undef strncpy

/* Global cddb_message definition */
char cddb_message[256];

/* Local structs for cddb_read input processing.  Hold char count for char arrays to prevent array bounds write */
struct __track_data {
  int ttitle_len;                  /* Amount of data in ttitle field */
  char ttitle[EXTENDED_DATA_SIZE]; /* Concatenate all TTITLE lines before parsing */
  int ext_len;                     /* Amount of data in corresponding track_data field */
};

struct __disc_data {
  int dtitle_len;                  /* Amount of data in dtitle field */
  char dtitle[EXTENDED_DATA_SIZE]; /* Concatenate all DTITLE lines before parsing */
  int genre_len;                   /* Amount of data in corresponding disc_data field */
  int ext_len;                     /* Amount of data in corresponding disc_data field */
  int track_total;                 /* Number of tracks */
  struct __track_data track[MAX_TRACKS];
};

/* CDDB sum function */
static int cddb_sum(int val)
{
  char *bufptr,buf[16];
  int ret=0;

  snprintf(buf,16,"%u",val);
  for(bufptr=buf;*bufptr!='\0';bufptr++)
    ret+=(*bufptr-'0');

  return ret;
}

/**
 * Return CDDB ID for CD in device with handle cd_desc.  
 * @param cd_desc the handle to the cd device containing CD from which to obtain CDDB ID.  
 * @return calculated CDDB ID on success, -1 on failure.  
 */
unsigned long cddb_discid(cddesc_t cd_desc)
{
  int index,discid,tracksum=0;
  struct disc_info disc;

  if(cd_stat(cd_desc,&disc)<0)
    return -1;

  if(!disc.disc_present)
    return -1;

  for(index=0;index<disc.disc_total_tracks;index++)
    tracksum+=cddb_sum(disc.disc_track[index].track_pos.minutes*60+disc.disc_track[index].track_pos.seconds);

  discid=(disc.disc_length.minutes*60+disc.disc_length.seconds)-(disc.disc_track[0].track_pos.minutes*60+disc.disc_track[0].track_pos.seconds);

  return ((tracksum%0xFF)<<24|discid<<8|disc.disc_total_tracks)&0xFFFFFFFF;
}

/**
 * Create a CDDB query string for the CD in device with handle cd_desc.  
 * The query string is used to query the CDDB server for exact and inexact 
 * database entries for a CD.  The string generated by this function is 
 * intended to be used with the function 'cddb_query'.  
 * @param cd_desc the handle to the cd device containing the cd from which to calculate the CDDB query string.  
 * @param query a character array in which to store the computed CDDB query string.  
 * @param len an integer specifying the size of 'query'.  
 * @return a pointer to 'query' on success, NULL on failure.  
 */
char* cddb_query_string(cddesc_t cd_desc,char *query,int len)
{
  int index;
  unsigned long discid;
  char outtemp[1024];
  struct disc_info disc;

  if(cd_stat(cd_desc,&disc)<0)
    return NULL;

  if((discid=cddb_discid(cd_desc))==-1)
    return NULL;

  snprintf(outtemp,sizeof(outtemp),"%d",disc.disc_total_tracks);
  for(index=0;index<disc.disc_total_tracks;index++)
  {
    strncpy(query,outtemp,len);
    snprintf(outtemp,sizeof(outtemp),"%s %d",query,(disc.disc_track[index].track_pos.minutes*60+disc.disc_track[index].track_pos.seconds)*75+disc.disc_track[index].track_pos.frames);
  }

  snprintf(query,len,"%08lx %s %d",discid,outtemp,disc.disc_length.minutes*60+disc.disc_length.seconds);
  return query;
}

/**
 * Create a generic entry for an unrecognized disc.  
 * The generated data may be used to represent a disc when 
 * a real entry is not found in the CDDB database or CDDB is 
 * unavailable.  
 * @param cd_desc the handle to the cd device containing the 
 *        cd from which to data should be generated.  
 * @param data a disc_data structure to be filled with the generated data.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_gen_unknown_entry(cddesc_t cd_desc,struct disc_data *data)
{
  struct disc_info disc;

  if(cd_stat(cd_desc,&disc)<0)
    return -1;

  if((data->data_id=cddb_discid(cd_desc))==-1)
    return -1;

  memset(data,0,sizeof(*data));
  data->data_category=CDDB_UNKNOWN;

  return 0;
}

/**
 * Allocate exact ammount of memory required for CDDB data structure.  
 * @param data pointer for allocated memory.  
 * @param tracks number of tracks to allocate space for.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_mc_alloc(struct disc_mc_data *data,int tracks)
{
  int index;

  data->data_id=0;
  data->data_category=CDDB_UNKNOWN;
  data->data_revision=0;
  data->data_total_tracks=tracks;
  data->data_artist=NULL;
  data->data_title=NULL;
  data->data_year=NULL;
  data->data_genre=NULL;
  data->data_extended=NULL;

  if((data->data_track=calloc(tracks,sizeof(struct track_mc_data)))==NULL)
    return -1;

  for(index=0;index<tracks;index++)
  {
    data->data_track[index]->track_title=NULL;
    data->data_track[index]->track_artist=NULL;
    data->data_track[index]->track_extended=NULL;
  }

  return 0;
}

/**
 * Free memory allocated for CDDB data structure.  
 * @param data pointer to memory to be freed.  
 */
void cddb_mc_free(struct disc_mc_data *data)
{
  int index=0,tracks=data->data_total_tracks;

  if(data->data_artist!=NULL)
    free(data->data_artist);

  if(data->data_title!=NULL)
    free(data->data_title);

  if(data->data_year!=NULL)
    free(data->data_year);

  if(data->data_genre!=NULL)
    free(data->data_genre);

  if(data->data_extended!=NULL)
    free(data->data_extended);

  for(index=0;index<tracks;index++)
  {
    if(data->data_track[index]->track_title!=NULL)
      free(data->data_track[index]->track_title);
    if(data->data_track[index]->track_artist!=NULL)
      free(data->data_track[index]->track_artist);
    if(data->data_track[index]->track_extended!=NULL)
      free(data->data_track[index]->track_extended);
  }

  free(data->data_track);
}

/**
 * Copy data from (large) fixed size structure to dynamically sized structure.  
 * @param out structure to copy data into.  Must have been previously allocated 
          with cddb_mc_alloc.  
 * @param in structure containing data to be copied.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_mc_copy_from_data(struct disc_mc_data *out,const struct disc_data *in)
{
  int track;

  out->data_id=in->data_id;
  out->data_category=in->data_category;
  out->data_revision=in->data_revision;

  if((out->data_artist=malloc(strlen(in->data_artist)+1))==NULL)
    return -1;
  strncpy(out->data_artist,in->data_artist,sizeof(out->data_artist));

  if((out->data_title=malloc(strlen(in->data_title)+1))==NULL)
    return -1;
  strncpy(out->data_title,in->data_title,sizeof(out->data_title));
   
  if((out->data_year=malloc(strlen(in->data_year)+1))==NULL)
    return -1;
  strncpy(out->data_year,in->data_year,sizeof(out->data_year));
   
  if((out->data_genre=malloc(strlen(in->data_genre)+1))==NULL)
    return -1;
  strncpy(out->data_genre,in->data_genre,sizeof(out->data_genre));
   
  if((out->data_extended=malloc(strlen(in->data_extended)+1))==NULL)
    return -1;
  strncpy(out->data_extended,in->data_extended,sizeof(out->data_extended));

  for(track=0;track<out->data_total_tracks;track++)
  {
    if((out->data_track[track]->track_title=malloc(strlen(in->data_track[track].track_title)+1))==NULL)
      return -1;
    strncpy(out->data_track[track]->track_title,in->data_track[track].track_title,sizeof(out->data_track[track]->track_title));

    if((out->data_track[track]->track_artist=malloc(strlen(in->data_track[track].track_artist)+1))==NULL)
      return -1;
    strncpy(out->data_track[track]->track_artist,in->data_track[track].track_artist,sizeof(out->data_track[track]->track_artist));

    if((out->data_track[track]->track_extended=malloc(strlen(in->data_track[track].track_extended)+1))==NULL)
      return -1;
    strncpy(out->data_track[track]->track_extended,in->data_track[track].track_extended,sizeof(out->data_track[track]->track_extended));
  }

  return 0;
}

/**
 * Copy data from dynamically allocated structure to (large) fixed size structure.  
 * @param out structure to copy data into.  
 * @param in structure containing data to be copied.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_data_copy_from_mc(struct disc_data *out,const struct disc_mc_data *in)
{
  int track;

  out->data_id=in->data_id;
  out->data_category=in->data_category;
  out->data_revision=in->data_revision;
  out->data_total_tracks=in->data_total_tracks;

  strncpy(out->data_artist,in->data_artist,sizeof(out->data_artist));
  strncpy(out->data_title,in->data_title,sizeof(out->data_title));
  strncpy(out->data_year,in->data_year,sizeof(out->data_year));
  strncpy(out->data_genre,in->data_genre,sizeof(out->data_genre));
  strncpy(out->data_extended,in->data_extended,sizeof(out->data_extended));

  for(track=0;track<in->data_total_tracks;track++)
  {
    strncpy(out->data_track[track].track_title,in->data_track[track]->track_title,sizeof(out->data_track[track].track_title));
    strncpy(out->data_track[track].track_artist,in->data_track[track]->track_artist,sizeof(out->data_track[track].track_artist));
    strncpy(out->data_track[track].track_extended,in->data_track[track]->track_extended,sizeof(out->data_track[track].track_extended));
  }

   return 0;
}

/**
 * Extract CDDB protocol, server address and port, and CGI script from URL.  
 * @param host structure into which extracted information is to be copied.  
 * @param url string with the URL to be processed.  
 * @return 0 on success, -1 on failure.  
 */
int cddb_process_url(struct cddb_host *host,const char *url)
{
  int index=0;
  char port[6];

  if(strchr(url,':')==NULL)
    return -1;

  while(url[index++]!=':')
  {
    if(index>5)
      return -1;
  }

  if(strncmp(url,"http",index-1)==0)
  {
    host->host_protocol=CDDB_MODE_HTTP;
    host->host_server.server_port=HTTP_DEFAULT_PORT;
  }
  else if(strncmp(url,"cddbp",index-1)==0)
  {
    host->host_protocol=CDDB_MODE_CDDBP;
    host->host_server.server_port=CDDBP_DEFAULT_PORT;
  }
  else
    return -1;

  url+=(index-1);

  if(strncmp(url,"://",3)!=0)
    return -1;

  url+=3;

  index=0;
  while(url[index]!=':'&&url[index]!='\0'&&url[index]!='/')
  {
    index++;
    if(index>255)
      return -1;
  }

  memset(host->host_server.server_name,'\0',sizeof(host->host_server.server_name));
  strncpy(host->host_server.server_name,url,index);

  if(url[index]==':')
  {
    url+=(index+1);
    index=0;
    while(url[index]!='\0'&&url[index]!='/')
    {
      index++;
      if(index>5)
        return -1;
    }

    memset(port,'\0',sizeof(port));
    strncpy(port,url,index);
    host->host_server.server_port=strtol(port,NULL,10);
  }

  memset(host->host_addressing,'\0',sizeof(host->host_addressing));

  if(url[index]=='/'&&url[index+1]!='\0')
  {
    url+=(index+1);
    index=0;
    while(url[index++]!='\0')
    {
      if(index>255)
        return -1;
    }

    strncpy(host->host_addressing,url,index);
  }

  return 0;
}

/**
 * Convert numerical identifier to text descriptor.  
 * @param category an integer identifying the category.  
 * @param buffer a character array to be used to store the text converted category type.  
 * @param len the size of the character array 'buffer'.  
 * @return a pointer to 'buffer'.  
 */
char* cddb_category(int category,char* buffer,int len)
{
  memset(buffer,0,len);
  switch(category)
  {
    case CDDB_BLUES:
      strncpy(buffer,"blues",len);
    case CDDB_CLASSICAL:
      strncpy(buffer,"classical",len);
    case CDDB_COUNTRY:
      strncpy(buffer,"country",len);
    case CDDB_DATA:
      strncpy(buffer,"data",len);
    case CDDB_FOLK:
      strncpy(buffer,"folk",len);
    case CDDB_JAZZ:
      strncpy(buffer,"jazz",len);
    case CDDB_MISC:
      strncpy(buffer,"misc",len);
    case CDDB_NEWAGE:
      strncpy(buffer,"newage",len);
    case CDDB_REGGAE:
      strncpy(buffer,"reggae",len);
    case CDDB_ROCK:
      strncpy(buffer,"rock",len);
    case CDDB_SOUNDTRACK:
      strncpy(buffer,"soundtrack",len);
    default:
      strncpy(buffer,"unknown",len);
  }

  return buffer;
}

/**
 * Convert category text descriptor to numerical identifier.  
 * @param category text descriptor to convert to numerical identifier.  
 * @return numerical identifier.  
 */
int cddb_category_value(const char *category)
{
  if(strcmp(category,"blues")==0)
    return CDDB_BLUES;
  else if(strcmp(category,"classical")==0)
    return CDDB_CLASSICAL;
  else if(strcmp(category,"country")==0)
    return CDDB_COUNTRY;
  else if(strcmp(category,"data")==0)
    return CDDB_DATA;
  else if(strcmp(category,"folk")==0)
    return CDDB_FOLK;
  else if(strcmp(category,"jazz")==0)
    return CDDB_JAZZ;
  else if(strcmp(category,"misc")==0)
    return CDDB_MISC;
  else if(strcmp(category,"newage")==0)
    return CDDB_NEWAGE;
  else if(strcmp(category,"reggae")==0)
    return CDDB_REGGAE;
  else if(strcmp(category,"rock")==0)
    return CDDB_ROCK;
  else if(strcmp(category,"soundtrack")==0)
    return CDDB_SOUNDTRACK;
  else
    return CDDB_UNKNOWN;
}

/*
 * Connect to a specified CDDB server.  
 * @param server a cddb_server structure specifying the CDDB 
 *        server with which to connect.  
 * @return handle to a connected socket on success, 
 *         INVALID_CDSOCKET on failure.  
 */
static cdsock_t cddb_connect_server(const struct cddb_server *server)
{
  cdsock_t sock;
  struct sockaddr_in sin;
  struct hostent *host;

  sin.sin_family=AF_INET;
  sin.sin_port=htons(server->server_port);
     
  if((sin.sin_addr.s_addr=inet_addr(server->server_name))==INADDR_NONE)
  {
    if((host=gethostbyname(server->server_name))==NULL)
    {
      strncpy(cddb_message,strerror(errno),sizeof(cddb_message));
      return INVALID_CDSOCKET;
    }
      
    memcpy(&sin.sin_addr,host->h_addr,host->h_length);
  }

  if((sock=socket(AF_INET,SOCK_STREAM,0))==INVALID_CDSOCKET)
  {
    strncpy(cddb_message,strerror(errno),sizeof(cddb_message));
    return INVALID_CDSOCKET;
  }

  if(connect(sock,(struct sockaddr *)&sin,sizeof(sin))==CDSOCKET_ERROR)
  {
    strncpy(cddb_message,strerror(errno),sizeof(cddb_message));
    return INVALID_CDSOCKET;
  }

  return sock;
}
  
/* Read a single line.  */
static int cddb_read_line(cdsock_t sock,char *inbuffer,int len)
{
  int index;
  char inchar;

  if(recv(sock,&inchar,1,0)!=1)
    return CDSOCKET_ERROR;

  len--;  /* Make sure their is always a null terminator.  */
  index=0;
  while(inchar!='\n'&&index<len)
  {
    if(inchar!='\r')
      inbuffer[index++]=inchar;
    if(recv(sock,&inchar,1,0)!=1)
      return CDSOCKET_ERROR;
  }

  inbuffer[index]='\0';
  return index;
}

/* 
 * Read server reply to a CDDB command.  Reply consists of an integer code 
 * (indicating either failure or success) and a text description separated by a ' '.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @param message a character array to be filled with the server's reply.  
 * @param len an integer specifying the size of 'message'.  
 * @return 0 on success, CDSOCKET_ERROR on failure.  
 */
static int cddb_read_reply(cdsock_t sock,char *message,int len)
{
  if(cddb_read_line(sock,message,len)==CDSOCKET_ERROR)
    return CDSOCKET_ERROR;

  if(strncmp(message,"<!DOC",5)==0)
    strncpy(message,"404 CDDB CGI not found",len);

  return 0;
}

/**
 * Connect to a specified CDDB server.  If protocol is HTTP, an HTTP initiaition 
 * string will be created.  
 * @param host a cddb_host structure specifying the CDDB 
 *        server with which to connect.  
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value 
 *        should be NULL.  
 * @param hello a variable argument only required when using HTTP.  
 *        This is a cddb_hello structure specifying the name and version 
 *        of the application connecting to the CDDB server.  
 * @param http_string a variable argument only required when using HTTP.  
 *        This is a character array to be filled by the function with a 
 *        CDDB handshake string.  This string will be required for further
 *        HTTP queries.  Note that the string for CDDB queries differs from
 *        the string for CDDB submissions.  When using CDDB with HTTP, separate
 *        connections for CDDB queries and submissions are required.  
 * @param https_string_len a variable argument only required when using HTTP.  
 *        This is an integer specifying the size of the http_string character array.  
 * @return handle to a connected socket on success, 
 *         INVALID_CDSOCKET on failure.  
 */
cdsock_t cddb_connect(const struct cddb_host *host,const struct cddb_server *proxy,...)
{
  cdsock_t sock;
  int http_string_len;
  char *http_string;
  struct cddb_hello *hello;

  if(proxy!=NULL)
  {
    if((sock=cddb_connect_server(proxy))==INVALID_CDSOCKET)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Failed to connect with proxy server");
      return INVALID_CDSOCKET;
    }
  }
  else
  {
    if((sock=cddb_connect_server(&host->host_server))==INVALID_CDSOCKET)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Failed to connect with %s",host->host_server.server_name);
      return INVALID_CDSOCKET;
    }
  }

  if(host->host_protocol==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,proxy);
    hello=va_arg(arglist,struct cddb_hello *);
    http_string=va_arg(arglist,char *);
    http_string_len=va_arg(arglist,int);

    if(proxy!=NULL)
      snprintf(http_string,http_string_len,"GET http://%s:%d/%s?hello=%s+%s+%s+%s&proto=%d HTTP/1.0\n\n",host->host_server.server_name,host->host_server.server_port,host->host_addressing,hello->hello_user,hello->hello_hostname,hello->hello_program,hello->hello_version,CDDB_PROTOCOL_LEVEL);
    else
      snprintf(http_string,http_string_len,"GET /%s?hello=%s+%s+%s+%s&proto=%d HTTP/1.0\n\n",host->host_addressing,hello->hello_user,hello->hello_hostname,hello->hello_program,hello->hello_version,CDDB_PROTOCOL_LEVEL);

    va_end(arglist);
  }
  else
  {
    if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return INVALID_CDSOCKET;
    }

    if(cddb_message[0]!='2')
    {
      cddb_close(sock);
      return INVALID_CDSOCKET;
    }

    return sock;
  }
}

/**
 * Initiate a CDDB CDDBP connection.  Required after use of 'cddb_connect'.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @param hello a cddb_hello structure specifying the name and version 
 *        of the application connecting to the CDDB server.  
 * @return 1 on handshake success, 0 on handshake failure, and CDSOCKET_ERROR 
 *         on socket failure.  
 */
int cddb_handshake(cdsock_t sock,const struct cddb_hello *hello)
{
  char outbuffer[1024];

  snprintf(outbuffer,sizeof(outbuffer),"cddb hello %s %s %s %s\n",hello->hello_user,hello->hello_hostname,hello->hello_program,hello->hello_version);

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_message[0]!='2')
  {
    return 0;
  }

  return 1;
}

/**
 * Set the CDDB protocol level for a CDDBP session to the protocol level 
 * supported by this library.  To be done after use of 'cddb_handshake'.  
 * This is required for some operations to function properly.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @return 1 on success, 0 on failure, and CDSOCKET_ERROR 
 *         on socket failure.  
 */ 
int cddb_proto(cdsock_t sock)
{
  char outbuffer[256];

  snprintf(outbuffer,sizeof(outbuffer),"proto %d\n",CDDB_PROTOCOL_LEVEL);

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_read_response(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if((cddb_message[0]!='2')&&(cddb_message[0]!='5'&&cddb_message[1]!='0'&&cddb_message[2]!='2'))
  {
    return 0;
  }

  return 1;
}

/* Generate the CDDB request string.  */
static int cddb_generate_http_request(char *outbuffer,const char *cmd,char *http_string,int outbufferlen)
{
  int index=0;
  char *reqstring;

  if((reqstring=strchr(http_string,'?'))==NULL)
    return -1;

  index=reqstring-http_string;
  http_string[index]='\0';
  reqstring++;

  snprintf(outbuffer,outbufferlen,"%s?cmd=%s&%s\n",http_string,cmd,reqstring);
  http_string[index]='?';

  return 0;
}

/* Skip HTTP header */
static int cddb_skip_http_header(cdsock_t sock)
{
  char inchar;
  int len;

  do
  {
    len=0;
    do
    {
      if(recv(sock,&inchar,1,0)!=1)
	return CDSOCKET_ERROR;
      len++;
    } while(inchar!='\n');
  } while(len>2);

  return 0;
}

/* Process a CDDB query string.  */
static int cddb_proc_query_string(char *line,struct query_list_entry* entry)
{
  char *start,*end;

  /* Advance to category.  */
  end=strchr(line,' ');
  if(end==NULL)
    return -1;
  *end='\0';
  entry->list_category=cddb_category_value(line);

  /* Advance to discid.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';
  entry->list_id=strtoul(start,NULL,16); 

  /* Advance to Artist name / Album title.  */
  start=end+1;
  end=strstr(start," / ");
  if(end==NULL)
  {
    /* There is no album title.  */
    strncpy(entry->list_artist,start,sizeof(entry->list_artist));
    strncpy(entry->list_title,start,sizeof(entry->list_title));
  }
  else
  {
    *end='\0';
    strncpy(entry->list_artist,start,sizeof(entry->list_artist));
    strncpy(entry->list_title,end+3,sizeof(entry->list_title));
  }

  return 0;
}

/**
 * Query CDDB for an entry corresponding to a specified CDDB id.  
 * The query provides a list of one or more exact and/or inexact matches
 * for the CDDB id specified.  After selecting an item from the list, the
 * corresponding CDDB entry can be retrieved with a subsequent call to 'cddb_read'.  
 * @param querystr a character string, specifying the CDDB id and disk 
 *        track info required for a CDDB query, obtained from 'cddb_query_string'.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @param mode an integer indicating CDDB server mode, either CDDBP or HTTP.  
 * @param query a cddb_query structure to be filled with CDDB query info.  
 * @param http_string a variable argument only required when using HTTP.  
 *        This is a character array filled with the CDDB handshake string
 *        obtained from 'cddb_connect'.  
 * @return 1 on query success, 0 on query failure, and CDSOCKET_ERROR 
 *         on socket failure.  
 */
int cddb_query(const char* querystr,cdsock_t sock,int mode,struct cddb_query *query,...)
{
  int index;
  char outbuffer[1024],outtemp[1024],inbuffer[256],*http_string;

  memset(query,0,sizeof(*query));

  if(mode==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,query);

    http_string=va_arg(arglist,char *);
    snprintf(outtemp,sizeof(outtemp),"cddb+query+%s",querystr);

    /* Replace any spaces with '+'.  */
    for(index=0;index<sizeof(outtemp)&&outtemp[index]!='\0';index++)
      if(outtemp[index]==' ') outtemp[index]='+';

    cddb_generate_http_request(outbuffer,outtemp,http_string,sizeof(outbuffer));

    va_end(arglist);
  }
  else
  {
    snprintf(outbuffer,sizeof(outbuffer),"cddb query %s\n",querystr);
  }

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(mode==CDDB_MODE_HTTP)
    cddb_skip_http_header(sock);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }
   
  if(cddb_message[0]!='2')
  {
    query->query_match=QUERY_NOMATCH;
    return 0;
  }
   
  /* First check for single exact match - return code 200.  */
  if(cddb_message[1]=='0')
  {
    if(cddb_message[2]!='0')
    {
      query->query_match=QUERY_NOMATCH;
      return 1;
    }

    query->query_match=QUERY_EXACT;
    query->query_matches=1;

    /* Copy message to inbuffer for processing.  */
    strncpy(inbuffer,cddb_message,sizeof(inbuffer));

    if(cddb_proc_query_string(&inbuffer[4],&query->query_list[0])==-1)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Error processing server reply");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }
  else if(cddb_message[1]==1)
  {
    /* Either multiple exact matches or inexact matches.  */
    if(cddb_message[2]==0)
      query->query_match=QUERY_EXACT;
    else if(cddb_message[2]==1)
      query->query_match=QUERY_INEXACT;
    else
    {
      query->query_match = QUERY_NOMATCH;
      return 1;
    }

    query->query_matches=0;
    if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }

    while(inbuffer[0]!='.')
    {
      /* Skip all tracks in excess of MAX_TRACKS.  */
      if(query->query_matches<MAX_TRACKS)
      {
        if(cddb_proc_query_string(inbuffer,&query->query_list[query->query_matches])==-1)
        {
          snprintf(cddb_message,sizeof(cddb_message),"Error processing server reply");
          cddb_close(sock);
          return CDSOCKET_ERROR;
	}
        query->query_matches++;
      }

      if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
      {
        snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
        cddb_close(sock);
        return CDSOCKET_ERROR;
      }
    }
  }
  else
  {
    query->query_match=QUERY_NOMATCH;
  }

  return 1;
}

/* 
 * Copy from data read from CDDB server from one buffer to the other, 
 * processing any excaped characters.  
 * @return number of bytes copied (does not include '\0')
 */
static int cddb_read_copy(char* dest,const char* src,int n)
{
  int index=0,total=0;
  char c;

  do
  {
    c=src[index++];
    if(c=='\\')
    {
      switch(src[index])
      {
      case 'n':
	c='\n';	index++;
	break;
      case 't':
	c='\t';	index++;
	break;
      case '\\':
	index++;
	break;
      }
    }
    dest[total]=c;
    if(c!='\0') total++;
  } while(c!='\0'&&total<n);
  return total;
}

/* Process a line read from CDDB database.  */
static int cddb_proc_read_string(char *line,struct disc_data *data,struct __disc_data *__data)
{
  int index=0;
  char *key,*value;

  /*Skip white space.  */
  while(isspace(line[index])) index++;

  if(line[index]=='#')
  {
    if(strstr(line,"Revision:")!=NULL)
    {
      value=strchr(line,':');
      while(!isdigit(value[index])&&value[index]!='\0')
        index++;
      data->data_revision=strtol(value,NULL,10);
    }
  }
  else
  {
    value=strchr(line,'=');
    if(value==NULL)
      return 0;

    key=line;
    *value='\0';
    value++;

    /* We ignore DISCID and PLAYORDER.  */
    if(strcmp(key,"DTITLE")==0)
    {
      /* Concatenate all DTITLE entries.  cddb_read will parse.  */
      __data->dtitle_len+=cddb_read_copy(&__data->dtitle[__data->dtitle_len],value,sizeof(__data->dtitle)-__data->dtitle_len-1);
    }
    else if(strcmp(key,"DYEAR")==0)
    {
      strncpy(data->data_year,value,4);
      data->data_year[4]='\0';
    }
    else if(strcmp(key,"DGENRE")==0)
    {
      /* Length minus one to ensure that when the whole buffer is filled, the last item is the terminator.  */
      __data->genre_len+=cddb_read_copy(&data->data_genre[__data->genre_len],value,sizeof(data->data_genre)-__data->genre_len-1);
    }
    else if(strncmp(key,"TTITLE",6)==0)
    {
      /* Get track number.  */
      index=strtol(key+6,NULL,10);
      if(index>=0&&index<MAX_TRACKS)
      {
        /* Concatenate all DTITLE entries.  cddb_read will parse.  */
        __data->track[index].ttitle_len+=cddb_read_copy(&__data->track[index].ttitle[__data->track[index].ttitle_len],value,sizeof(__data->track[index].ttitle)-__data->track[index].ttitle_len-1);

        /* Update the number of tracks, with highest known track value.  */
	if(__data->track_total<index) __data->track_total=index;
      }
    }
    else if(strcmp(key,"EXTD")==0)
    {
      /* Length minus one to ensure that when the whole buffer is filled, the last item is the terminator.  */
      __data->ext_len+=cddb_read_copy(&data->data_extended[__data->ext_len],value,sizeof(data->data_extended)-__data->ext_len-1);
    }
    else if(strncmp(key,"EXTT",4)==0)
    {
      /* Get track number.  */
      index=strtol(key+4,NULL,10);
      if(index>=0&&index<MAX_TRACKS)
      {
        /* Length minus one to ensure that when the whole buffer is filled, the last item is the terminator.  */
        __data->track[index].ext_len+=cddb_read_copy(&data->data_track[index].track_extended[__data->track[index].ext_len],value,sizeof(data->data_track[index].track_extended)-__data->track[index].ext_len-1);
      }
    }
  }

  return 0;
}

/**
 * Read CDDB data for a specified CDDB entry.  
 * @param category an integer specifying the category for the disc whose 
 *        data is to be retrieved.  
 * @param discid an unsigned long specifying the id for the disc whose data
 *        is to be retrieved.  
 * @param sock handle to the socket connected to the CDDB server.  
 * @param mode an integer indicating CDDB server mode, either CDDBP or HTTP.  
 * @param data a disc_data structure to be filled with retrieved CDDB data.  
 * @param http_string a variable argument only required when using HTTP.  
 *        This is a character array filled with the CDDB handshake string
 *        obtained from 'cddb_connect'.  
 * @return 1 on read success, 0 on read failure, and CDSOCKET_ERROR 
 *         on socket failure.  
 */
int cddb_read(int category,unsigned long discid,cdsock_t sock,int mode,struct disc_data *data,...)
{
  int index;
  char outbuffer[1024],outtemp[1024],inbuffer[256],*http_string,*artist,*title;
  struct __disc_data __data;

  memset(&__data,0,sizeof(__data));
  memset(data,0,sizeof(*data));

  if(mode==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,data);

    http_string=va_arg(arglist,char *);
    snprintf(outtemp,sizeof(outtemp),"cddb+read+%s+%08lx",cddb_category(category,inbuffer,sizeof(inbuffer)),discid);
    cddb_generate_http_request(outbuffer,outtemp,http_string,sizeof(outbuffer));

    va_endlist(arglist);
  }
  else
  {
    snprintf(outbuffer,sizeof(outbuffer),"cddb read %s %08lx\n",cddb_category(category,inbuffer,sizeof(inbuffer)),discid);
  }

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(mode==CDDB_MODE_HTTP)
    cddb_skip_http_header(sock);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_message[0]!=2&&cddb_message[1]!=1)
    return 0;

  data->data_id=discid;
  data->data_category=category;

  if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  while(inbuffer[0]!='.')
  {
    cddb_proc_read_string(inbuffer,data,&__data);

    if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }

  /* Get album artist name and title.  */
  artist=__data.dtitle;
  title=strstr(artist," / ");
  if(title==NULL)
  {
    /* Minus one to ensure that if the entire buffer is filled, the last item is '\0'.  */
    strncpy(data->data_artist,artist,sizeof(data->data_artist)-1);
    strncpy(data->data_title,artist,sizeof(data->data_title)-1);
  }
  else
  {
    *title='\0';
    strncpy(data->data_artist,artist,sizeof(data->data_artist)-1);
    strncpy(data->data_title,title+3,sizeof(data->data_title)-1);
  }
  
  for(index=0;index<=__data.track_total;index++)
  {
    artist=__data.track[index].ttitle;
    title=strstr(artist," / ");
    if(title==NULL)
    {
      strncpy(data->data_track[index].track_title,artist,sizeof(data->data_track[index].track_title)-1);
      data->data_track[index].track_artist[0]='\0';
    }
    else
    {
      *title='\0';
      strncpy(data->data_track[index].track_artist,artist,sizeof(data->data_track[index].track_artist)-1);
      strncpy(data->data_track[index].track_title,title+3,sizeof(data->data_track[index].track_title)-1);
    }
  }

  /* Set the total number of track entries in list.  */
  data->data_total_tracks=__data.track_total+1;

  return 1;
}

/* Process a single line in the sites list */
static int cddb_proc_sites_line(char *line,struct cddb_host *host)
{
  int index=0;
  char *start,*end;

  /* Extract site address.  */
  end=strchr(line,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  strncpy(host->host_server.server_name,line,sizeof(host->host_server.server_name));

  /* Extract protocol.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  if(strncasecmp(start,"cddbp",5)==0)
    host->host_protocol=CDDB_MODE_CDDBP;
  else if(strncasecmp(start,"http",4)==0)
    host->host_protocol=CDDB_MODE_HTTP;
  else
    return -1;

  /* Extract port.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  host->host_server.server_port=strtol(start,NULL,10);

  /* Extract addressing.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  if(strcmp(start,"-")==0)
    host->host_addressing[0]='\0';
  else
    strncpy(host->host_addressing,start,sizeof(host->host_addressing));

  /* Extract latitude.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  strncpy(host->host_latitude,start,sizeof(host->host_latitude));

  /* Extract longitude.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  strncpy(host->host_longitude,start,sizeof(host->host_longitude));

  /* Extract description.  */
  start=end+1;
  strncpy(host->host_description,start,sizeof(host->host_description));

  return 0;
}

/* Read the CDDB sites list */
int cddb_sites(cdsock_t sock,int mode,struct cddb_serverlist *list,...)
{
  char outbuffer[1024],inbuffer[256],*http_string;

  memset(list,0,sizeof(*list));

  if(mode==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,list);
    http_string=va_arg(arglist,char *);
    cddb_generate_http_request(outbuffer,"sites",http_string,sizeof(outbuffer));
    va_end(arglist);
  }
  else
    strcpy(outbuffer,"sites\n");

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(mode==CDDB_MODE_HTTP)
    cddb_skip_http_header(sock);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_message[0]!=2)
    return 0;

  list->list_len=0;
  if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  while(inbuffer[0]!='.')
  {
    if(cddb_sites_process_line(inbuffer,&list->list_host[list->list_len])!=-1)
      list->list_len++;
  
    if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }

  return 1;
}

/* Terminate the connection */
int cddb_quit(cdsock_t sock,int mode)
{
  char outbuffer[]="quit\n";

  if(mode==CDDB_MODE_CDDBP)
  {
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }

    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }

  cddb_close(sock);
  return 0;
}









/*

int cddb_http_submit(int cd_desc,const struct cddb_host *host,struct cddb_server *proxy,char *email_address)
{
  FILE *cddb_entry;
  int sock,index,changed_artist=0,changed_track[MAX_TRACKS],token[3],error=0;
  char inbuffer[512],outbuffer[512],cddb_file[PATH_MAX],*home;
  struct stat st;
  struct cddb_entry entry;
  struct disc_info disc;
  struct disc_data data;
   
  if((home=getenv("HOME"))==NULL)
  {
    if(use_cddb_message)
      strncpy(cddb_message,"$HOME is not set!",256);
    return -1;
  }

  if(cd_stat(cd_desc,&disc)<0)
    return -1;

  if(!disc.disc_present)
    return -1;

  if(cddb_stat_disc_data(cd_desc,&entry)<0)
    return -1;

  if(entry.entry_present)
  {
    if(cddb_read_disc_data(cd_desc,&data)<0)
      return -1;
  }
  else
  {
    if(use_cddb_message)
      strncpy(cddb_message,"No CDDB entry present in cache",256);
    return -1;
  }

  if(proxy!=NULL)
  {
    if((sock=cddb_connect(proxy))<0)
    {
      if(use_cddb_message)
	strncpy(cddb_message,strerror(errno),256);
      return -1;
    }
  }
  else
  {
    if((sock=cddb_connect(&host->host_server))<0)
    {
      if(use_cddb_message)
	strncpy(cddb_message,strerror(errno),256);
      return -1;
    }
  }

  if(strlen(data.data_title)<1||strcmp(data.data_title,"Unknown")==0)
  {
    if(use_cddb_message)
      strncpy(cddb_message,"Edit the disc title before submission.",256);
    return -1;
  }

  if(strcmp(data.data_artist,"Unknown")==0)
  {
    strncpy(data.data_artist,"",256);
    changed_artist = 1;
  }

  for(index=0;index<disc.disc_total_tracks;index++)
  {
    changed_track[index]=0;
    if(strcmp(data.data_track[index].track_name,"Unknown")==0)
    {
      snprintf(data.data_track[index].track_name,256,"Track %d",index);
      changed_track[index]=1;
    }
  }

  cddb_write_data(cd_desc,&data);

  if(cddb_submit_method==CDDB_SUBMIT_EMAIL)
  {
    snprintf(outbuffer,512,"cat %s/.cddb/%s/%08lx | mail -s \"cddb %s %08lx\" %s",home,cddb_genre(data.data_genre),data.data_id,cddb_genre(data.data_genre),data.data_id,cddb_submit_email_address);
    if(system(outbuffer) != 0)
      return -1;
    return 0;
  }

  if(proxy!=NULL)
    snprintf(outbuffer,512,"POST http://%s:%d%s HTTP/1.0\n",host->host_server.server_name,host->host_server.server_port,CDDB_HTTP_SUBMIT_CGI);
  else
    snprintf(outbuffer,512,"POST %s HTTP/1.0\n",CDDB_HTTP_SUBMIT_CGI);
  write(sock,outbuffer,strlen(outbuffer));

  snprintf(outbuffer,512,"Category: %s\n",cddb_genre(data.data_genre));
  write(sock,outbuffer,strlen(outbuffer));

  snprintf(outbuffer,512,"Discid: %08lx\n",data.data_id);
  write(sock,outbuffer,strlen(outbuffer));

  snprintf(outbuffer,512,"User-Email: %s\n",email_address);
  write(sock,outbuffer,strlen(outbuffer));

  snprintf(outbuffer,512,"Submit-Mode: %s\n",CDDB_SUBMIT_MODE?"submit":"test");
  write(sock,outbuffer,strlen(outbuffer));

  strncpy(outbuffer,"X-Cddbd-Note: Submission problems?  E-mail libcdaudio@gjhsnews.mesa.k12.co.us\n",512);
  write(sock, outbuffer, strlen(outbuffer));

  snprintf(cddb_file,PATH_MAX,"%s/.cddb/%s/%08lx",home,cddb_genre(data.data_genre),data.data_id);
  stat(cddb_file,&st);

  snprintf(outbuffer,512,"Content-Length: %d\n\n",(int)st.st_size);
  write(sock,outbuffer,strlen(outbuffer));

  cddb_entry=fopen(cddb_file,"r");
  while(!feof(cddb_entry))
  {
    fgets(outbuffer,512,cddb_entry);
    write(sock,outbuffer,strlen(outbuffer));
  }

  cddb_read_line(sock,inbuffer,512);
  if(strncmp(inbuffer+9,"200",3)!=0)
  {
    if(use_cddb_message)
      strncpy(cddb_message,inbuffer,256);
    return -1;
  }

  cddb_skip_http_header(sock);

  if(cddb_read_token(sock,token)<0)
    error = 1;

  if(token[0]!=2)
    error = 1;

  close(sock);

  if(changed_artist)
    strncpy(data.data_artist,"Unknown",256);

  for(index=0;index<disc.disc_total_tracks;index++)
  {
    if(changed_track[index])
      strncpy(data.data_track[index].track_name,"Unknown",256);
  }

  data.data_revision++;
  cddb_write_data(cd_desc, &data);

  if(error)
    return -1;

  return 0;
}

*/
