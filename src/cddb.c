/*
This is part of the audio CD player library
Copyright (C)1998-99 Tony Arcieri <bascule@inferno.tusculum.edu>
Copyright (C)2001-04,2010 Dustin Graves <dgraves@computer.org>

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with this library; if not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA  02111-1307, USA.
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <math.h>

#ifndef WIN32
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#endif

#include "cdlyte.h"

#ifndef INADDR_NONE
#define INADDR_NONE 0xFFFFFFFF
#endif

#ifndef PATH_MAX
#if defined(_MAX_PATH)
#define PATH_MAX  _MAX_PATH
#elif defined(MAX_PATH)
#define PATH_MAX  MAX_PATH
#else
#define PATH_MAX  1024
#endif
#endif

/* Some procedures differ on Windows.  */
#ifndef WIN32
#define PATHSEP '/'
#define cddb_close close
#else
#define PATHSEP '\\'
#define cddb_close closesocket
#define strcasecmp  _stricmp
#define strncasecmp _strnicmp
#define snprintf _snprintf
#endif

#define CDDB_INT_STRLEN(x) (((x)<0)?((int)log10(x))+2:((int)log10(x))+1)

/* Global cddb_message definition */
char cddb_message[CDDB_LINE_SIZE];

/* cddb_test_submit definition */
static int cddb_test_submit=0;

/* CDDB category strings */
static const char *cddb_categories[]={"unkown",       /* CDDB_UNKNOWN    = 0  */
                                      "blues",        /* CDDB_BLUES      = 1  */
                                      "classical",    /* CDDB_CLASSICAL  = 2  */
                                      "country",      /* CDDB_COUNTRY    = 3  */
                                      "data",         /* CDDB_DATA       = 4  */
                                      "folk",         /* CDDB_FOLK       = 5  */
                                      "jazz",         /* CDDB_JAZZ       = 6  */
                                      "misc",         /* CDDB_MISC       = 7  */
                                      "newage",       /* CDDB_NEWAGE     = 8  */
                                      "reggae",       /* CDDB_REGGAE     = 9  */
                                      "rock",         /* CDDB_ROCK       = 10 */
                                      "soundtrack"};  /* CDDB_SOUNDTRACK = 11 */

/* CDDB sum function */
static int cddb_sum(int val)
{
  char *bufptr,buf[16];
  int ret=0;

  snprintf(buf,16,"%u",val);
  for(bufptr=buf;*bufptr!='\0';bufptr++)
    ret+=(*bufptr-'0');

  return ret;
}

/**
 * Return CDDB ID for CD in device with handle cd_desc.
 * @param cd_desc the handle to the cd device containing CD from which to obtain CDDB ID.
 * @return calculated CDDB ID on success, 0 on failure.
 */
unsigned long cddb_discid(cddesc_t cd_desc)
{
  unsigned long cddbid;
  int index,discid,tracksum=0;
  struct disc_info disc;

  cd_init_disc_info(&disc);

  if(cd_stat(cd_desc,&disc)<0)
  {
    cd_free_disc_info(&disc);
    return 0;
  }

  if(!disc.disc_present)
  {
    cd_free_disc_info(&disc);
    return 0;
  }

  for(index=0;index<disc.disc_total_tracks;index++)
    tracksum+=cddb_sum(disc.disc_track[index].track_pos.minutes*60+disc.disc_track[index].track_pos.seconds);

  discid=(disc.disc_track[disc.disc_total_tracks].track_pos.minutes*60+disc.disc_track[disc.disc_total_tracks].track_pos.seconds)-
         (disc.disc_track[0].track_pos.minutes*60+disc.disc_track[0].track_pos.seconds);

  cddbid=((tracksum%0xFF)<<24|discid<<8|disc.disc_total_tracks)&0xFFFFFFFF;

  cd_free_disc_info(&disc);

  return cddbid;
}

/**
 * Create a CDDB query string for the CD in device with handle cd_desc.
 * The query string is used to query the CDDB server for exact and inexact
 * database entries for a CD.  The string generated by this function is
 * intended to be used with the function 'cddb_query'.
 * @param cd_desc the handle to the cd device containing the cd from which to calculate the CDDB query string.
 * @param query a character array in which to store the computed CDDB query string.
 * @param len a pointer to an integer specifying the size of 'query'.
 * @return a pointer to 'query' on success, NULL on failure.  If failure was a result of
 *         insufficient space in 'query', 'len' will be set to the required size for the query
 *         string.  Otherwise 'len' will be set to 0 on failure.
 */
char* cddb_query_string(cddesc_t cd_desc, char *query, int *len)
{
  unsigned long discid;
  int index;
  int querylen;
  char tempstr[BUFSIZ];
  struct disc_info disc;

  if((discid=cddb_discid(cd_desc))==0)
  {
    *len=0;
    return NULL;
  }

  cd_init_disc_info(&disc);

  if(cd_stat(cd_desc,&disc)<0)
  {
    *len=0;
    cd_free_disc_info(&disc);
    return NULL;
  }

  /* Calculate string length for disc */
  querylen=9;                                           /* 8 characters for hex discid value plus 1 for space */
  querylen+=CDDB_INT_STRLEN(disc.disc_total_tracks)+1;  /* Plus 1 for space */
  for(index=0;index<disc.disc_total_tracks;index++)
    querylen+=CDDB_INT_STRLEN((disc.disc_track[index].track_pos.minutes*60+disc.disc_track[index].track_pos.seconds)*75+disc.disc_track[index].track_pos.frames)+1;  /* Plus 1 for space */
  querylen+=CDDB_INT_STRLEN(disc.disc_length.minutes*60+disc.disc_length.seconds)+1;  /* Plus 1 for null terminator */

  if(querylen>*len)
  {
    *len=querylen;
    cd_free_disc_info(&disc);
    return NULL;
  }

  snprintf(query,*len,"%08lx %d ",discid,disc.disc_total_tracks);
  for(index=0;index<disc.disc_total_tracks;index++)
  {
    snprintf(tempstr,sizeof(tempstr),"%d ",(disc.disc_track[index].track_pos.minutes*60+disc.disc_track[index].track_pos.seconds)*75+disc.disc_track[index].track_pos.frames);
    strcat(query,tempstr);
  }

  snprintf(tempstr,sizeof(tempstr),"%d",disc.disc_length.minutes*60+disc.disc_length.seconds);
  strcat(query,tempstr);

  cd_free_disc_info(&disc);

  return query;
}

/* Duplicate a string for a cddb strcuture, to be freed by one of the cddb_free functions.  */
char* cddb_strdup(const char* str)
{
  char *dup;

  if(str==NULL) return NULL;
  dup=(char*)malloc(strlen(str)+1);
  if(dup==NULL) return NULL;
  strcpy(dup,str);

  return dup;
}

/** Initialize disc_data structure.
 * @param data a disc_data structure to be initialized.
 */
void cddb_init_disc_data(struct disc_data *data)
{
  memset(data,0,sizeof(struct disc_data));
}

/** Free resources allocated for disc_data structure.
 * @param data a disc_data structure with memory resources to be freed.
 */
void cddb_free_disc_data(struct disc_data *data)
{
  int i;

  if(data->data_artist!=NULL)
  {
    free(data->data_artist);
    data->data_artist=NULL;
  }

  if(data->data_title!=NULL)
  {
    free(data->data_title);
    data->data_title=NULL;
  }

  if(data->data_genre!=NULL)
  {
    free(data->data_genre);
    data->data_genre=NULL;
  }

  if(data->data_track!=NULL)
  {
    for(i=0;i<data->data_total_tracks;i++)
    {
      if(data->data_track[i].track_artist!=NULL) free(data->data_track[i].track_artist);
      if(data->data_track[i].track_title!=NULL) free(data->data_track[i].track_title);
      if(data->data_track[i].track_extended!=NULL) free(data->data_track[i].track_extended);
    }

    free(data->data_track);
    data->data_track=NULL;
    data->data_total_tracks=0;
  }

  if(data->data_extended!=NULL)
  {
    free(data->data_extended);
    data->data_extended=NULL;
  }
}

/** Initialize cddb_query structure.
 * @param query a cddb_query structure to be initialized.
 */
void cddb_init_cddb_query(struct cddb_query *query)
{
  query->query_match=0;
  query->query_matches=0;
  query->query_list=NULL;
}

/** Free resources allocated for cddb_querystructure.
 * @param query a cddb_query structure with memory resources to be freed.
 */
void cddb_free_cddb_query(struct cddb_query *query)
{
  int i;

  if(query->query_list!=NULL)
  {
    for(i=0;i<query->query_matches;i++)
    {
      if(query->query_list[i].list_title!=NULL) free(query->query_list[i].list_title);
      if(query->query_list[i].list_artist!=NULL) free(query->query_list[i].list_artist);
    }

    free(query->query_list);
    query->query_list=NULL;
    query->query_matches=0;
  }
}

/** Initialize cddb_host structure.
 * @param host a cddb_host structure to be initialized.
 */
void cddb_init_cddb_host(struct cddb_host *host)
{
  cddb_init_cddb_server(&host->host_server);
  host->host_protocol=0;
  host->host_addressing=NULL;
  host->host_latitude=NULL;
  host->host_longitude=NULL;
  host->host_description=NULL;
}

/** Free resources allocated for cddb_host structure.
 * @param host a cddb_host structure with memory resources to be freed.
 */
void cddb_free_cddb_host(struct cddb_host *host)
{
  if(host->host_server.server_name!=NULL)
  {
    free(host->host_server.server_name);
    host->host_server.server_name=NULL;
  }

  if(host->host_addressing!=NULL)
  {
    free(host->host_addressing);
    host->host_addressing=NULL;
  }

  if(host->host_latitude!=NULL)
  {
    free(host->host_latitude);
    host->host_latitude=NULL;
  }

  if(host->host_longitude!=NULL)
  {
    free(host->host_longitude);
    host->host_longitude=NULL;
  }

  if(host->host_description!=NULL)
  {
    free(host->host_description);
    host->host_description=NULL;
  }
}

/** Initialize cddb_hello structure.
 * @param hello a cddb_hello structure to be initialized.
 */
void cddb_init_cddb_hello(struct cddb_hello *hello)
{
  hello->hello_user=NULL;
  hello->hello_hostname=NULL;
  hello->hello_program=NULL;
  hello->hello_version=NULL;
}

/** Free resources allocated for cddb_hello structure.
 * @param hello a cddb_hello structure with memory resources to be freed.
 */
void cddb_free_cddb_hello(struct cddb_hello *hello)
{
  if(hello->hello_user)
  {
    free(hello->hello_user);
    hello->hello_user=NULL;
  }

  if(hello->hello_hostname)
  {
    free(hello->hello_hostname);
    hello->hello_hostname=NULL;
  }

  if(hello->hello_program)
  {
    free(hello->hello_program);
    hello->hello_program=NULL;
  }

  if(hello->hello_version)
  {
    free(hello->hello_version);
    hello->hello_version=NULL;
  }
}

/** Initialize cddb_server structure.
 * @param server a cddb_server structure to be initialized.
 */
void cddb_init_cddb_server(struct cddb_server *server)
{
  server->server_name=NULL;
  server->server_port=0;
}

/** Free resources allocated for cddb_server.
 * @param server a cddb_server structure with memory resources to be freed.
 */
void cddb_free_cddb_server(struct cddb_server *server)
{
  free(server->server_name);
}

/** Initialize cddb_serverlist structure.
 * @param list a cddb_serverlist structure to be initialized.
 */
void cddb_init_cddb_serverlist(struct cddb_serverlist *list)
{
  list->list_len=0;
  list->list_host=NULL;
}

/** Free resources allocated for cddb_serverlist structure.
 * @param list a cddb_serverlist structure with memory resources to be freed.
 */
void cddb_free_cddb_serverlist(struct cddb_serverlist *list)
{
  int i;

  if(list->list_host!=NULL)
  {
    for(i=0;i<list->list_len;i++)
    {
      if(list->list_host[i].host_server.server_name!=NULL) free(list->list_host[i].host_server.server_name);
      if(list->list_host[i].host_addressing!=NULL) free(list->list_host[i].host_addressing);
      if(list->list_host[i].host_latitude!=NULL) free(list->list_host[i].host_latitude);
      if(list->list_host[i].host_longitude!=NULL) free(list->list_host[i].host_longitude);
      if(list->list_host[i].host_description!=NULL) free(list->list_host[i].host_description);
    }

    free(list->list_host);
    list->list_host=NULL;
    list->list_len=0;
  }
}

/**
 * Create a generic entry for an unrecognized disc.
 * The generated data may be used to represent a disc when
 * a real entry is not found in the CDDB database or CDDB is
 * unavailable.
 * @param cd_desc the handle to the cd device containing the
 *        cd from which to data should be generated.
 * @param data a disc_data structure to be filled with the generated data.
 * @return 0 on success, -1 on failure.
 */
int cddb_gen_unknown_entry(cddesc_t cd_desc,struct disc_data *data)
{
  int i;
  char tempstr[BUFSIZ];
  struct disc_info disc;
  unsigned long discid=cddb_discid(cd_desc);

  if(discid==0)
    return -1;

  cd_init_disc_info(&disc);

  if(cd_stat(cd_desc,&disc)<0)
  {
    cd_free_disc_info(&disc);
    return -1;
  }

  if(data->data_artist!=NULL) free(data->data_artist);
  if(data->data_title!=NULL) free(data->data_title);
  if(data->data_genre!=NULL) free(data->data_genre);
  if(data->data_track!=NULL) free(data->data_track);
  if(data->data_extended!=NULL) free(data->data_extended);

  data->data_id=discid;
  data->data_category=CDDB_UNKNOWN;
  data->data_revision=0;
  data->data_artist=strdup("Unknown Artist");
  data->data_title=strdup("Unknown Album");
  memset(data->data_year,0,sizeof(data->data_year));
  data->data_genre=strdup("Unknown");
  data->data_total_tracks=disc.disc_total_tracks;
  data->data_track=(struct track_data *)malloc(data->data_total_tracks*sizeof(struct track_data));
  for(i=0;i<data->data_total_tracks;i++)
  {
    snprintf(tempstr,sizeof(tempstr),"Track %d",i+disc.disc_first_track);
    data->data_track[i].track_artist=strdup("Unknown Artist");
    data->data_track[i].track_title=strdup(tempstr);
    data->data_track[i].track_extended=strdup("");
  }
  data->data_extended=strdup("");

  cd_free_disc_info(&disc);

  return 0;
}

/**
 * Extract CDDB protocol, server address and port, and CGI script from URL.
 * @param host structure into which extracted information is to be copied.
 * @param url string with the URL to be processed.
 * @return 0 on success, -1 on failure.
 */
int cddb_process_url(struct cddb_host *host,const char *url)
{
  int index=0;
  char port[6];

  if(strchr(url,':')==NULL)
    return -1;

  while(url[index++]!=':')
  {
    if(index>5)
      return -1;
  }

  if(strncmp(url,"http",index-1)==0)
  {
    host->host_protocol=CDDB_MODE_HTTP;
    host->host_server.server_port=HTTP_DEFAULT_PORT;
  }
  else if(strncmp(url,"cddbp",index-1)==0)
  {
    host->host_protocol=CDDB_MODE_CDDBP;
    host->host_server.server_port=CDDBP_DEFAULT_PORT;
  }
  else
    return -1;

  url+=(index-1);

  if(strncmp(url,"://",3)!=0)
    return -1;

  url+=3;

  index=0;
  while(url[index]!=':'&&url[index]!='\0'&&url[index]!='/')
    index++;

  if(host->host_server.server_name!=NULL) free(host->host_server.server_name);
  host->host_server.server_name=(char *)malloc(index+1);  /* Plus 1 for null terminator */
  strncpy(host->host_server.server_name,url,index);

  if(url[index]==':')
  {
    url+=(index+1);
    index=0;
    while(url[index]!='\0'&&url[index]!='/')
    {
      index++;
      if(index>5)
        return -1;
    }

    memset(port,'\0',sizeof(port));
    strncpy(port,url,index);
    host->host_server.server_port=strtol(port,NULL,10);
  }

  if(host->host_addressing!=NULL) free(host->host_addressing);
  host->host_addressing=NULL;

  if(url[index]=='/'&&url[index+1]!='\0')
  {
    url+=(index+1);
    index=0;
    while(url[index++]!='\0')
    {
      if(index>255)
        return -1;
    }

    host->host_addressing=(char *)malloc(index+1);  /* Plus 1 for null terminator */
    strncpy(host->host_addressing,url,index);
  }

  return 0;
}

/**
 * Convert numerical identifier to text descriptor.
 * @param category an integer identifying the category.
 * @param buffer a character array to be used to store the text converted category type.
 * @param len the size of the character array 'buffer'.
 * @return a pointer to 'buffer' or NULL if there was not enough space in 'buffer' for
 *         category string.  If return value is NULL, 'len' will be set to the required
 *         size for the query string.
 */
char* cddb_category(int category,char* buffer,int *len)
{
  int catlen;

  if(category<CDDB_UNKNOWN||category>CDDB_SOUNDTRACK)
    category=CDDB_UNKNOWN;

  catlen=strlen(cddb_categories[category])+1;  /* Plus one for null terminator */
  if(catlen>*len)
  {
    *len=catlen;
    return NULL;
  }

  strncpy(buffer,cddb_categories[category],*len);

  return buffer;
}

/**
 * Convert category text descriptor to numerical identifier.
 * @param category text descriptor to convert to numerical identifier.
 * @return numerical identifier.
 */
int cddb_category_value(const char *category)
{
  int i;

  for(i=0;i<=CDDB_SOUNDTRACK;i++)
  {
    if(strcmp(category,cddb_categories[i])==0)
      return i;
  }

  return CDDB_UNKNOWN;
}

/*
 * Connect to a specified CDDB server.
 * @param server a cddb_server structure specifying the CDDB
 *        server with which to connect.
 * @return handle to a connected socket on success,
 *         INVALID_CDSOCKET on failure.
 */
static cdsock_t cddb_connect_server(const struct cddb_server *server)
{
  cdsock_t sock;
  struct sockaddr_in sin;
  struct hostent *host;

  sin.sin_family=AF_INET;
  sin.sin_port=htons(server->server_port);

  if((sin.sin_addr.s_addr=inet_addr(server->server_name))==INADDR_NONE)
  {
    if((host=gethostbyname(server->server_name))==NULL)
    {
      strncpy(cddb_message,strerror(errno),sizeof(cddb_message));
      return INVALID_CDSOCKET;
    }

    memcpy(&sin.sin_addr,host->h_addr,host->h_length);
  }

  if((sock=socket(AF_INET,SOCK_STREAM,0))==INVALID_CDSOCKET)
  {
    strncpy(cddb_message,strerror(errno),sizeof(cddb_message));
    return INVALID_CDSOCKET;
  }

  if(connect(sock,(struct sockaddr *)&sin,sizeof(sin))==CDSOCKET_ERROR)
  {
    strncpy(cddb_message,strerror(errno),sizeof(cddb_message));
    cddb_close(sock);
    return INVALID_CDSOCKET;
  }

  return sock;
}

/* Read a single line.  */
static int cddb_read_line(cdsock_t sock,char *inbuffer,int len)
{
  int index;
  char inchar;

  if(recv(sock,&inchar,1,0)!=1)
    return CDSOCKET_ERROR;

  len--;  /* Make sure their is always a null terminator.  */
  index=0;
  while(inchar!='\n'&&index<len)
  {
    if(inchar!='\r')
      inbuffer[index++]=inchar;
    if(recv(sock,&inchar,1,0)!=1)
      return CDSOCKET_ERROR;
  }

  inbuffer[index]='\0';
  return index;
}

/*
 * Read server reply to a CDDB command.  Reply consists of an integer code
 * (indicating either failure or success) and a text description separated by a ' '.
 * @param sock handle to the socket connected to the CDDB server.
 * @param message a character array to be filled with the server's reply.
 * @param len an integer specifying the size of 'message'.
 * @return 0 on success, CDSOCKET_ERROR on failure.
 */
static int cddb_read_reply(cdsock_t sock,char *message,int len)
{
  if(cddb_read_line(sock,message,len)==CDSOCKET_ERROR)
    return CDSOCKET_ERROR;

  if(strncmp(message,"<!DOC",5)==0)
    strncpy(message,"404 CDDB CGI not found",len);

  return 0;
}

/**
 * Connect to a specified CDDB server.  If protocol is HTTP, an HTTP initiaition
 * string will be created.
 * @param host a cddb_host structure specifying the CDDB
 *        server with which to connect.
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value
 *        should be NULL.
 * @param hello a variable argument only required when using HTTP.
 *        This is a cddb_hello structure specifying the name and version
 *        of the application connecting to the CDDB server.
 * @param http_string a variable argument only required when using HTTP.
 *        This is a character array to be filled by the function with a
 *        CDDB handshake string.  This string will be required for further
 *        HTTP queries.  Note that the string for CDDB queries differs from
 *        the string for CDDB submissions.  When using CDDB with HTTP, separate
 *        connections for CDDB queries and submissions are required.
 * @param https_string_len a variable argument only required when using HTTP.
 *        This is a pointer to an integer specifying the size of the http_string
 *        character array.  If connection aborts because 'http_string' does not have
 *        enough space, 'http_string_len' will be set to the required size for the query
 *        string.  Otherwise 'http_string_len' will be set to 0 on failure.
 * @return handle to a connected socket on success,
 *         INVALID_CDSOCKET on failure.
 */
cdsock_t cddb_connect(const struct cddb_host *host,const struct cddb_server *proxy,...)
{
  cdsock_t sock;
  int httplen;
  int *http_string_len=NULL;
  char *http_string;
  struct cddb_hello *hello;
  va_list arglist;

  if(host->host_protocol==CDDB_MODE_HTTP)
  {
    va_start(arglist,proxy);
    hello=va_arg(arglist,struct cddb_hello *);
    http_string=va_arg(arglist,char *);
    http_string_len=va_arg(arglist,int *);

    httplen=strlen(host->host_addressing)+strlen(hello->hello_user)+strlen(hello->hello_hostname)+strlen(hello->hello_program)+strlen(hello->hello_version)+CDDB_INT_STRLEN(CDDB_PROTOCOL_LEVEL);
    if(proxy!=NULL)
    {
      httplen+=strlen(host->host_server.server_name)+CDDB_INT_STRLEN(host->host_server.server_port);
      httplen+=strlen("GET http://:?hello=+++&proto= HTTP/1.0\r\n\r\n")+1;                             // Plus 1 for null terminator
    }
    else
    {
      httplen+=strlen("GET ?hello=+++&proto= HTTP/1.0\r\n\r\n")+1;                                     // Plus 1 for null terminator
    }

    if(httplen>*http_string_len)
    {
      *http_string_len=httplen;
      snprintf(cddb_message,sizeof(cddb_message),"Insufficient space in HTTP string buffer for HTTP string");
      return INVALID_CDSOCKET;
    }
  }

  if(proxy!=NULL)
  {
    if((sock=cddb_connect_server(proxy))==INVALID_CDSOCKET)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Failed to connect with proxy server");
      if(http_string_len!=NULL) *http_string_len=0;
      return INVALID_CDSOCKET;
    }
  }
  else
  {
    if((sock=cddb_connect_server(&host->host_server))==INVALID_CDSOCKET)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Failed to connect with %s",host->host_server.server_name);
      if(http_string_len!=NULL) *http_string_len=0;
      return INVALID_CDSOCKET;
    }
  }

  if(host->host_protocol==CDDB_MODE_HTTP)
  {
    if(proxy!=NULL)
      snprintf(http_string,*http_string_len,"GET http://%s:%d%s?hello=%s+%s+%s+%s&proto=%d HTTP/1.0\r\n\r\n",host->host_server.server_name,host->host_server.server_port,host->host_addressing,hello->hello_user,hello->hello_hostname,hello->hello_program,hello->hello_version,CDDB_PROTOCOL_LEVEL);
    else
      snprintf(http_string,*http_string_len,"GET %s?hello=%s+%s+%s+%s&proto=%d HTTP/1.0\r\n\r\n",host->host_addressing,hello->hello_user,hello->hello_hostname,hello->hello_program,hello->hello_version,CDDB_PROTOCOL_LEVEL);
  }
  else
  {
    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      if(http_string_len!=NULL) *http_string_len=0;
      return INVALID_CDSOCKET;
    }

    if(cddb_message[0]!='2')
    {
      cddb_close(sock);
      if(http_string_len!=NULL) *http_string_len=0;
      return INVALID_CDSOCKET;
    }
  }

  if(host->host_protocol==CDDB_MODE_HTTP)
    va_end(arglist);

  return sock;
}

/**
 * Initiate a CDDB CDDBP connection.  Required after use of 'cddb_connect'.
 * @param sock handle to the socket connected to the CDDB server.
 * @param hello a cddb_hello structure specifying the name and version
 *        of the application connecting to the CDDB server.
 * @return 1 on handshake success, 0 on handshake failure, and CDSOCKET_ERROR
 *         on socket failure.
 */
int cddb_handshake(cdsock_t sock,const struct cddb_hello *hello)
{
  int len;
  char *outbuffer;

  len=strlen(hello->hello_user)+strlen(hello->hello_hostname)+strlen(hello->hello_program)+strlen(hello->hello_version);
  len+=strlen("cddb hello    \n")+1;  /* Plus 1 for null terminator */

  outbuffer=(char *)malloc(len);
  snprintf(outbuffer,len,"cddb hello %s %s %s %s\n",hello->hello_user,hello->hello_hostname,hello->hello_program,hello->hello_version);

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  free(outbuffer);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_message[0]!='2')
  {
    return 0;
  }

  return 1;
}

/**
 * Set the CDDB protocol level for a CDDBP session to the protocol level
 * supported by this library.  To be done after use of 'cddb_handshake'.
 * This is required for some operations to function properly.
 * @param sock handle to the socket connected to the CDDB server.
 * @return 1 on success, 0 on failure, and CDSOCKET_ERROR
 *         on socket failure.
 */
int cddb_proto(cdsock_t sock)
{
  int len;
  char *outbuffer;

  len=CDDB_INT_STRLEN(CDDB_PROTOCOL_LEVEL);
  len+=strlen("proto \n")+1;  /* Plus 1 for null terminator */

  outbuffer=(char *)malloc(len);
  snprintf(outbuffer,len,"proto %d\n",CDDB_PROTOCOL_LEVEL);

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  free(outbuffer);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if((cddb_message[0]!='2')&&(cddb_message[0]!='5'&&cddb_message[1]!='0'&&cddb_message[2]!='2'))
  {
    return 0;
  }

  return 1;
}

/* Generate the CDDB request string.  */
static char* cddb_generate_http_request(const char *cmd,char *http_string)
{
  int len,index=0;
  char *outbuffer,*reqstring;

  if((reqstring=strchr(http_string,'?'))==NULL)
    return NULL;

  index=reqstring-http_string;
  http_string[index]='\0';
  reqstring++;

  len=strlen(http_string)+strlen(cmd)+strlen(reqstring);
  len+=strlen("?cmd=&\n")+1;  /* Plus 1 for null terminator */

  outbuffer=(char *)malloc(len);
  snprintf(outbuffer,len,"%s?cmd=%s&%s\n",http_string,cmd,reqstring);
  http_string[index]='?';

  return outbuffer;
}

/* Skip HTTP header */
static int cddb_skip_http_header(cdsock_t sock)
{
  char inchar;
  int len;

  do
  {
    len=0;
    do
    {
      if(recv(sock,&inchar,1,0)!=1)
	return CDSOCKET_ERROR;
      len++;
    } while(inchar!='\n');
  } while(len>2);

  return 0;
}

/* Process a CDDB query string.  */
static int cddb_proc_query_string(char *line,struct query_list_entry* entry)
{
  char *start,*end;

  /* Advance to category.  */
  end=strchr(line,' ');
  if(end==NULL)
    return -1;
  *end='\0';
  entry->list_category=cddb_category_value(line);

  /* Advance to discid.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';
  entry->list_id=strtoul(start,NULL,16);

  /* Advance to Artist name / Album title.  */
  start=end+1;
  end=strstr(start," / ");
  if(end==NULL)
  {
    /* There is no album title.  */
    entry->list_artist=strdup(start);
    entry->list_title=strdup(start);
  }
  else
  {
    *end='\0';
    entry->list_artist=strdup(start);
    entry->list_title=strdup(end+3);
  }

  return 0;
}

/**
 * Query CDDB for an entry corresponding to a specified CDDB id.
 * The query provides a list of one or more exact and/or inexact matches
 * for the CDDB id specified.  After selecting an item from the list, the
 * corresponding CDDB entry can be retrieved with a subsequent call to 'cddb_read'.
 * @param querystr a character string, specifying the CDDB id and disk
 *        track info required for a CDDB query, obtained from 'cddb_query_string'.
 * @param sock handle to the socket connected to the CDDB server.
 * @param mode an integer indicating CDDB server mode, either CDDBP or HTTP.
 * @param query a cddb_query structure to be filled with CDDB query info.
 * @param http_string a variable argument only required when using HTTP.
 *        This is a character array filled with the CDDB handshake string
 *        obtained from 'cddb_connect'.
 * @return 1 on query success, 0 on query failure, and CDSOCKET_ERROR
 *         on socket failure.
 */
int cddb_query(const char* querystr,cdsock_t sock,int mode,struct cddb_query *query,...)
{
  int i,index;
  char inbuffer[CDDB_LINE_SIZE],*outbuffer,*http_string;

  if(query->query_list!=NULL)
  {
    for(i=0;i<query->query_matches;i++)
    {
      if(query->query_list[i].list_title!=NULL) free(query->query_list[i].list_title);
      if(query->query_list[i].list_artist!=NULL) free(query->query_list[i].list_artist);
    }

    free(query->query_list);
    query->query_list=NULL;
  }
  query->query_matches=0;

  if(mode==CDDB_MODE_HTTP)
  {
    int outlen;
    char *outtemp;
    va_list arglist;
    va_start(arglist,query);

    http_string=va_arg(arglist,char *);

    outlen=strlen(querystr)+strlen("cddb+query+")+1;  /* Plus 1 for null terminator */
    outtemp=(char *)malloc(outlen);
    snprintf(outtemp,outlen,"cddb+query+%s",querystr);

    /* Replace any spaces with '+'.  */
    for(index=0;index<outlen&&outtemp[index]!='\0';index++)
      if(outtemp[index]==' ') outtemp[index]='+';

    outbuffer=cddb_generate_http_request(outtemp,http_string);

    free(outtemp);

    va_end(arglist);
  }
  else
  {
    int outlen=strlen(querystr)+strlen("cddb query \n")+1;  /* Plus 1 for null terminator */
    outbuffer=(char *)malloc(outlen);
    snprintf(outbuffer,outlen,"cddb query %s\n",querystr);
  }

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    free(outbuffer);
    return CDSOCKET_ERROR;
  }

  free(outbuffer);

  if(mode==CDDB_MODE_HTTP)
    cddb_skip_http_header(sock);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_message[0]!='2')
  {
    query->query_match=QUERY_NOMATCH;
    return 0;
  }

  /* First check for single exact match - return code 200.  */
  if(cddb_message[1]=='0')
  {
    if(cddb_message[2]!='0')
    {
      query->query_match=QUERY_NOMATCH;
      return 1;
    }

    query->query_match=QUERY_EXACT;
    query->query_matches=1;
    query->query_list=(struct query_list_entry *)malloc(sizeof(struct query_list_entry));
    query->query_list[0].list_artist=NULL;
    query->query_list[0].list_title=NULL;


    /* Copy message to inbuffer for processing.  */
    strncpy(inbuffer,cddb_message,sizeof(inbuffer));

    if(cddb_proc_query_string(&inbuffer[4],&query->query_list[0])==-1)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Error processing server reply");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }
  else if(cddb_message[1]=='1')
  {
    /* Either multiple exact matches or inexact matches.  */
    if(cddb_message[2]=='0')
      query->query_match=QUERY_EXACT;
    else if(cddb_message[2]=='1')
      query->query_match=QUERY_INEXACT;
    else
    {
      query->query_match = QUERY_NOMATCH;
      return 1;
    }

    if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }

    while(inbuffer[0]!='.')
    {
      query->query_list=(struct query_list_entry *)realloc(query->query_list,(query->query_matches+1)*sizeof(struct query_list_entry));
      query->query_list[query->query_matches].list_artist=NULL;
      query->query_list[query->query_matches].list_title=NULL;

      if(cddb_proc_query_string(inbuffer,&query->query_list[query->query_matches])==-1)
      {
        snprintf(cddb_message,sizeof(cddb_message),"Error processing server reply");
        cddb_close(sock);
        return CDSOCKET_ERROR;
      }
      query->query_matches++;

      if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
      {
        snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
        cddb_close(sock);
        return CDSOCKET_ERROR;
      }
    }
  }
  else
  {
    query->query_match=QUERY_NOMATCH;
  }

  return 1;
}

/*
 * Copy from data read from CDDB server from one buffer to the other,
 * processing any excaped characters.
 * @return number of bytes copied (does not include '\0')
 */
static int cddb_read_copy(char* dest,const char* src,int n)
{
  int index=0,total=0;
  char c;

  do
  {
    c=src[index++];
    if(c=='\\')
    {
      switch(src[index])
      {
      case 'n':
	c='\n';	index++;
	break;
      case 't':
	c='\t';	index++;
	break;
      case '\\':
	index++;
	break;
      }
    }
    dest[total]=c;
    if(c!='\0') total++;
  } while(c!='\0'&&total<n);
  return total;
}

/* Process a line read from CDDB database.  */
static int cddb_proc_read_string(char *line,struct disc_data *data)
{
  int index=0;
  char *key,*value,buffer[CDDB_LINE_SIZE];

  /*Skip white space.  */
  while(isspace(line[index])) index++;

  if(line[index]=='#')
  {
    if(strstr(line,"Revision:")!=NULL)
    {
      value=strchr(line,':');
      while(!isdigit(*value)&&*value!='\0')
        value++;
      data->data_revision=strtol(value,NULL,10);
    }
  }
  else
  {
    value=strchr(line,'=');
    if(value==NULL)
      return 0;

    key=line;
    *value='\0';
    value++;

    memset(buffer,0,sizeof(buffer));

    /* We ignore DISCID and PLAYORDER.  */
    if(strcmp(key,"DTITLE")==0)
    {
      /* Concatenate all DTITLE entries.  cddb_read will parse.  */
      cddb_read_copy(buffer,value,sizeof(buffer));
      if(data->data_title==NULL)
        data->data_title=strdup(buffer);
      else
      {
        data->data_title=(char *)realloc(data->data_title,strlen(buffer));
        strcat(data->data_title, buffer);
      }
    }
    else if(strcmp(key,"DYEAR")==0)
    {
      strncpy(data->data_year,value,4);
      data->data_year[4]='\0';
    }
    else if(strcmp(key,"DGENRE")==0)
    {
      cddb_read_copy(buffer,value,sizeof(buffer));
      data->data_genre=strdup(buffer);
    }
    else if(strncmp(key,"TTITLE",6)==0)
    {
      /* Get track number.  */
      index=strtol(key+6,NULL,10);

      if(index>=data->data_total_tracks)
      {
        data->data_track=(struct track_data *)realloc(data->data_track,(index+1)*sizeof(struct track_data));
        data->data_track[index].track_artist=NULL;
        data->data_track[index].track_title=NULL;
        data->data_track[index].track_extended=NULL;
        data->data_total_tracks=index+1;
      }

      /* Concatenate all TTITLE entries.  cddb_read will parse.  */
      cddb_read_copy(buffer,value,sizeof(buffer));
      if(data->data_track[index].track_title==NULL)
        data->data_track[index].track_title=strdup(buffer);
      else
      {
        data->data_track[index].track_title=(char *)realloc(data->data_track[index].track_title,strlen(buffer));
        strcat(data->data_track[index].track_title, buffer);
      }
    }
    else if(strcmp(key,"EXTD")==0)
    {
      cddb_read_copy(buffer,value,sizeof(buffer));
      if(data->data_extended==NULL)
        data->data_extended=strdup(buffer);
      else
      {
        data->data_extended=(char *)realloc(data->data_extended,strlen(buffer));
        strcat(data->data_extended, buffer);
      }
    }
    else if(strncmp(key,"EXTT",4)==0)
    {
      /* Get track number.  */
      index=strtoul(key+4,NULL,10);

      if(index>=data->data_total_tracks)
      {
        data->data_track=(struct track_data *)realloc(data->data_track,(index+1)*sizeof(struct track_data));
        data->data_track[index].track_artist=NULL;
        data->data_track[index].track_title=NULL;
        data->data_track[index].track_extended=NULL;
        data->data_total_tracks=index+1;
      }

      /* Concatenate all EXTT entries.  cddb_read will parse.  */
      cddb_read_copy(buffer,value,sizeof(buffer));
      if(data->data_track[index].track_extended==NULL)
        data->data_track[index].track_extended=strdup(buffer);
      else
      {
        data->data_track[index].track_extended=(char *)realloc(data->data_track[index].track_extended,strlen(buffer));
        strcat(data->data_track[index].track_extended, buffer);
      }
    }
  }

  return 0;
}

/* Process parse artist names and song titles.  */
static void cddb_proc_read_data(struct disc_data *data)
{
  int index;
  char *artist,*title;

  /* Get album artist name and title.  */
  artist=data->data_title;
  title=strstr(artist," / ");
  if(title==NULL)
  {
    data->data_artist=strdup(artist);
  }
  else
  {
    *title='\0';
    data->data_artist=strdup(artist);
    data->data_title=strdup(title+3);
    free(artist);
  }

  for(index=0;index<data->data_total_tracks;index++)
  {
    artist=data->data_track[index].track_title;
    title=strstr(artist," / ");
    if(title==NULL)
    {
      data->data_track[index].track_artist=strdup("");
    }
    else
    {
      *title='\0';
      data->data_track[index].track_artist=strdup(artist);
      data->data_track[index].track_title=strdup(title+3);
      free(artist);
    }
  }
}

/**
 * Read CDDB data for a specified CDDB entry.
 * @param category an integer specifying the category for the disc whose
 *        data is to be retrieved.
 * @param discid an unsigned long specifying the id for the disc whose data
 *        is to be retrieved.
 * @param sock handle to the socket connected to the CDDB server.
 * @param mode an integer indicating CDDB server mode, either CDDBP or HTTP.
 * @param data a disc_data structure to be filled with the retrieved CDDB data.
 * @param http_string a variable argument only required when using HTTP.
 *        This is a character array filled with the CDDB handshake string
 *        obtained from 'cddb_connect'.
 * @return 1 on read success, 0 on read failure, and CDSOCKET_ERROR
 *         on socket failure.
 */
int cddb_read(int category,unsigned long discid,cdsock_t sock,int mode,struct disc_data *data,...)
{
  int i;
  char inbuffer[CDDB_LINE_SIZE],*outbuffer,*http_string;

  if(data->data_artist!=NULL) free(data->data_artist);
  if(data->data_title!=NULL) free(data->data_title);
  if(data->data_genre!=NULL) free(data->data_genre);
  if(data->data_extended!=NULL) free(data->data_extended);
  if(data->data_track!=NULL)
  {
    for(i=0;i<data->data_total_tracks;i++)
    {
      if(data->data_track[i].track_artist!=NULL) free(data->data_track[i].track_artist);
      if(data->data_track[i].track_title!=NULL) free(data->data_track[i].track_title);
      if(data->data_track[i].track_extended!=NULL) free(data->data_track[i].track_extended);
    }
    free(data->data_track);
  }
  memset(data,0,sizeof(*data));

  if(category<CDDB_UNKNOWN||category>CDDB_SOUNDTRACK)
    category=CDDB_UNKNOWN;

  if(mode==CDDB_MODE_HTTP)
  {
    int outlen;
    char* outtemp;
    va_list arglist;
    va_start(arglist,data);

    http_string=va_arg(arglist,char *);

    outlen=strlen(cddb_categories[category])+8;  /* Plus 8 for hex number */
    outlen+=strlen("cddb+read++")+1;  /* Plus 1 for null terminator */

    outtemp=(char *)malloc(outlen);
    snprintf(outtemp,outlen,"cddb+read+%s+%08lx",cddb_categories[category],discid);

    outbuffer=cddb_generate_http_request(outtemp,http_string);

    free(outtemp);

    va_end(arglist);
  }
  else
  {
    int outlen=strlen(cddb_categories[category])+8;  /* Plus 8 for hex number */
    outlen+=strlen("cddb read  \n")+1;  /* Plus 1 for null terminator */
    outbuffer=(char *)malloc(outlen);
    snprintf(outbuffer,outlen,"cddb read %s %08lx\n",cddb_categories[category],discid);
  }

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    free(outbuffer);
    return CDSOCKET_ERROR;
  }

  free(outbuffer);

  if(mode==CDDB_MODE_HTTP)
    cddb_skip_http_header(sock);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_message[0]!='2'&&cddb_message[1]!='1')
    return 0;

  data->data_id=discid;
  data->data_category=category;

  if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  while(inbuffer[0]!='.')
  {
    cddb_proc_read_string(inbuffer,data);

    if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }

  cddb_proc_read_data(data);

  return 1;
}

/* Process a single line in the sites list.  */
static int cddb_proc_sites_line(char *line,struct cddb_host *host)
{
  char *start,*end;

  /* Extract site address.  */
  end=strchr(line,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  host->host_server.server_name=strdup(line);

  /* Extract protocol.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  if(strncasecmp(start,"cddbp",5)==0)
    host->host_protocol=CDDB_MODE_CDDBP;
  else if(strncasecmp(start,"http",4)==0)
    host->host_protocol=CDDB_MODE_HTTP;
  else
    return -1;

  /* Extract port.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  host->host_server.server_port=strtol(start,NULL,10);

  /* Extract addressing.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  if(host->host_addressing!=NULL) free(host->host_addressing);
  if(strcmp(start,"-")==0)
    host->host_addressing=strdup("");
  else
    host->host_addressing=strdup(start);

  /* Extract latitude.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  host->host_latitude=strdup(start);

  /* Extract longitude.  */
  start=end+1;
  end=strchr(start,' ');
  if(end==NULL)
    return -1;
  *end='\0';

  host->host_longitude=strdup(start);

  /* Extract description.  */
  start=end+1;
  host->host_description=strdup(start);

  return 0;
}

/**
 * Read the list of CDDB server sites.
 * @param sock handle to the socket connected to the CDDB server.
 * @param mode an integer indicating CDDB server mode, either CDDBP or HTTP.
 * @param list a cddb_serverlist structure to be filled with the retrieved server data.
 * @param http_string a variable argument only required when using HTTP.
 *        This is a character array filled with the CDDB handshake string
 *        obtained from 'cddb_connect'.
 * @return 1 on read success, 0 on read failure, and CDSOCKET_ERROR
 *         on socket failure.
 */
int cddb_sites(cdsock_t sock,int mode,struct cddb_serverlist *list,...)
{
  int i;
  char inbuffer[CDDB_LINE_SIZE],*outbuffer,*http_string;

  if(list->list_host!=NULL)
  {
    for(i=0;i<list->list_len;i++)
    {
      if(list->list_host[i].host_server.server_name!=NULL) free(list->list_host[i].host_server.server_name);
      if(list->list_host[i].host_addressing!=NULL) free(list->list_host[i].host_addressing);
      if(list->list_host[i].host_latitude!=NULL) free(list->list_host[i].host_latitude);
      if(list->list_host[i].host_longitude!=NULL) free(list->list_host[i].host_longitude);
      if(list->list_host[i].host_description!=NULL) free(list->list_host[i].host_description);
    }

    free(list->list_host);
    list->list_host=NULL;
  }
  list->list_len=0;

  if(mode==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,list);
    http_string=va_arg(arglist,char *);
    outbuffer=cddb_generate_http_request("sites",http_string);
    va_end(arglist);
  }
  else
  {
    outbuffer=(char *)malloc(strlen("sites\n")+1);  /* Plus one for null terminator */
    strcpy(outbuffer,"sites\n");
  }

  if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  free(outbuffer);

  if(mode==CDDB_MODE_HTTP)
    cddb_skip_http_header(sock);

  if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  if(cddb_message[0]!='2')
    return 0;

  if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
    cddb_close(sock);
    return CDSOCKET_ERROR;
  }

  while(inbuffer[0]!='.')
  {
    list->list_host=(struct cddb_host *)realloc(list->list_host,(list->list_len+1)*sizeof(struct cddb_host));
    list->list_host[list->list_len].host_server.server_name=NULL;
    list->list_host[list->list_len].host_addressing=NULL;
    list->list_host[list->list_len].host_latitude=NULL;
    list->list_host[list->list_len].host_longitude=NULL;
    list->list_host[list->list_len].host_description=NULL;

    if(cddb_proc_sites_line(inbuffer,&list->list_host[list->list_len])==-1)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Error processing server reply");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
    list->list_len++;

    if(cddb_read_line(sock,inbuffer,sizeof(inbuffer))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }

  return 1;
}

/**
 * Terminate the connection to the CDDB server.  If the server mode
 * is CDDBP, the quit command will be issued and the socket will be closed.
 * If hte server mode is HTTP the socket will simply be closed.
 * @param sock handle to the socket connected to the CDDB server.
 * @param mode an integer indicating CDDB server mode, either CDDBP or HTTP.
 * @return 0 on success, and CDSOCKET_ERROR on socket failure.
 */
int cddb_quit(cdsock_t sock,int mode)
{
  char outbuffer[]="quit\n";

  if(mode==CDDB_MODE_CDDBP)
  {
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }

    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      return CDSOCKET_ERROR;
    }
  }

  cddb_close(sock);
  return 0;
}

/* Read a single line from a file.  */
static int cddb_read_file_line(FILE* fd,char *inbuffer,int len)
{
  int index;
  char inchar;

  len--;  /* Make sure their is always a null terminator.  */
  index=0;

  inchar=fgetc(fd);
  while(inchar!=EOF&&inchar!='\n'&&index<len)
  {
    if(inchar!='\r')
      inbuffer[index++]=inchar;
    inchar=fgetc(fd);
  }

  inbuffer[index]='\0';
  return index;
}

/**
 * Read CDDB data from a local directory.
 * @param path a string containing the path to the directory containig
 *        the local CDDB data files.
 * @param discid an unsigned long specifying the id of the CD whose CDDB
 *        data is to be read.
 * @param data a disc_data structure to be filled with the read CDDB data.
 * @return 0 on success, -1 on failure.
 */
int cddb_read_local(const char *path,unsigned long discid,struct disc_data *data)
{
  int i,len;
  char file[PATH_MAX],inbuffer[CDDB_LINE_SIZE];
  FILE* fd;

  if(data->data_artist!=NULL) free(data->data_artist);
  if(data->data_title!=NULL) free(data->data_title);
  if(data->data_genre!=NULL) free(data->data_genre);
  if(data->data_extended!=NULL) free(data->data_extended);
  if(data->data_track!=NULL)
  {
    for(i=0;i<data->data_total_tracks;i++)
    {
      if(data->data_track[i].track_artist!=NULL) free(data->data_track[i].track_artist);
      if(data->data_track[i].track_title!=NULL) free(data->data_track[i].track_title);
      if(data->data_track[i].track_extended!=NULL) free(data->data_track[i].track_extended);
    }
    free(data->data_track);
  }
  memset(data,0,sizeof(*data));

  len=strlen(path);
  if(path[len-1]==PATHSEP)
    snprintf(file,sizeof(file),"%s%08lx",path,discid);
  else
    snprintf(file,sizeof(file),"%s%c%08lx",path,PATHSEP,discid);

  if((fd=fopen(file,"r"))==NULL)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Could not open file %s",file);
    return -1;
  }

  /* Read lines and process.  */
  data->data_id=discid;
  data->data_category=CDDB_UNKNOWN;

  cddb_read_file_line(fd,inbuffer,sizeof(inbuffer));
  while(!feof(fd)&&!ferror(fd)&&inbuffer[0]!='.')
  {
    cddb_proc_read_string(inbuffer,data);
    cddb_read_file_line(fd,inbuffer,sizeof(inbuffer));
  }

  cddb_proc_read_data(data);

  /* Return -1 if error was encountered.  */
  if(ferror(fd))
  {
    snprintf(cddb_message,sizeof(cddb_message),"Error reading file %s",file);
    fclose(fd);
    return -1;
  }

  fclose(fd);

  /* Return 0 if EOF or '.' was found.  */
  return 0;
}

/* Write a line to file.  */
static int cddb_write_file_line(FILE* fd,const char *key,const char* value)
{
  int count=0,total=0;
  char outchar,special='\0';

  fprintf(fd,"%s",key);
  count=strlen(key);

  outchar='=';
  while(outchar!='\0')
  {
    /* Character 256 should be the new line.  */
    if(count>=255)
    {
      fputc('\n',fd);
      total+=count+1;
      fprintf(fd,"%s=",key);
      count=strlen(key)+1;
    }

    switch(outchar)
    {
    case '\n':
      outchar='\\';
      special='n';
      break;
    case '\t':
      outchar='\\';
      special='t';
      break;
    case '\\':
      /* If special is already '\\', we are midway through '\\' write.  */
      if(special!='\\')
      {
        outchar='\\';
        special='\\';
      }
      break;
    }

    fputc(outchar,fd);
    count++;

    if(special!='\0')
    {
      outchar=special;
      special='\0';
    }
    else
      outchar=*value++;
  }

  /* Replace '\0' with '\n'.  'count' is <= 255,  */
  fputc('\n',fd);
  count++;

  return total+count;
}

/*  Write data to file.  */
static int cddb_write_local_file(FILE* fd,const struct cddb_hello *hello,const struct disc_info *info,const struct disc_data *data,const char *comment)
{
  int index,len;
  char key[CDDB_LINE_SIZE],*outbuffer;

  fprintf(fd,"# xmcd\n#\n# Track frame offset:\n");
  for(index=0;index<info->disc_total_tracks;index++)
    fprintf(fd,"#        %d\n",(info->disc_track[index].track_pos.minutes*60+info->disc_track[index].track_pos.seconds)*75+info->disc_track[index].track_pos.frames);
  fprintf(fd,"#\n# Disc length: %d seconds\n",(info->disc_length.minutes*60)+info->disc_length.seconds);

  if(comment!=NULL)
    fprintf(fd,"#\n# Revision: %d\n# Submitted via: %s %s %s\n#\n",data->data_revision,hello->hello_program,hello->hello_version,comment);
  else
    fprintf(fd,"#\n# Revision: %d\n# Submitted via: %s %s\n#\n",data->data_revision,hello->hello_program,hello->hello_version);

  fprintf(fd,"DISCID=%08lx\n",data->data_id);
  if(data->data_title[0]=='\0')
    cddb_write_file_line(fd,"DTITLE",data->data_artist);
  else
  {
    len=strlen(data->data_artist)+strlen(data->data_title)+strlen(" / ")+1;  /* Plus one for null terminator */
    outbuffer=(char *)malloc(len);
    snprintf(outbuffer,len,"%s / %s",data->data_artist,data->data_title);
    cddb_write_file_line(fd,"DTITLE",outbuffer);
    free(outbuffer);
  }

  cddb_write_file_line(fd,"DYEAR",data->data_year);
  cddb_write_file_line(fd,"DGENRE",data->data_genre);

  for(index=0;index<data->data_total_tracks;index++)
  {
    snprintf(key,sizeof(key),"TTITLE%d",index);
    if(data->data_track[index].track_artist[0]=='\0')
      cddb_write_file_line(fd,key,data->data_track[index].track_title);
    else
    {
      len=strlen(data->data_track[index].track_artist)+strlen(data->data_track[index].track_title)+strlen(" / ")+1;  /* Plus one for null terminator */
      outbuffer=(char *)malloc(len);
      snprintf(outbuffer,len,"%s / %s",data->data_track[index].track_artist,data->data_track[index].track_title);
      cddb_write_file_line(fd,key,outbuffer);
      free(outbuffer);
    }
  }

  cddb_write_file_line(fd,"EXTD",data->data_extended);

  for(index=0;index<data->data_total_tracks;index++)
  {
    snprintf(key,sizeof(key),"EXTT%d",index);
    cddb_write_file_line(fd,key,data->data_track[index].track_extended);
  }

  fprintf(fd,"PLAYORDER=\n.\n");

  return (ferror(fd))?-1:0;
}

/**
 * Write CDDB data to a local directory.
 * @param path a string containing the path to the directory containig
 *        the local CDDB data files.
 * @param hello a cddb_hello structure containing the name and version
 *        numberof the program that is writing the CDDB data.  Only the
 *        'hello_program' and 'hello_version' fields need to be filled.
 *        The 'hello_user' and 'hello_hostname' fields will be ignored.
 * @param info a disc_info structure containing the frame offsets and total
 *        length for the CD whose CDDB data is to be written.  Obtained from
 *        the 'cd_stat' function.
 * @param data a disc_data structure containing the CDDB data to be written.
 * @param comment a character string specifying a comment to be added to the
 *        CDDB data file.  This parameter is optional, and may be NULL.
 * @return 0 on success, -1 on failure.
 */
int cddb_write_local(const char *path,const struct cddb_hello *hello,const struct disc_info *info,const struct disc_data *data,const char *comment)
{
  int len;
  char file[PATH_MAX];
  FILE* fd;

  len=strlen(path);
  if(path[len-1]==PATHSEP)
    snprintf(file,sizeof(file),"%s%08lx",path,data->data_id);
  else
    snprintf(file,sizeof(file),"%s%c%08lx",path,PATHSEP,data->data_id);

  /* Binary to prevent inclusion of carriage return with WIN32.  */
  if((fd=fopen(file,"wb"))==NULL)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Could not open file %s for writing",file);
    return -1;
  }

  if(cddb_write_local_file(fd,hello,info,data,comment)<0)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Error writing file %s",file);
    fclose(fd);
    return -1;
  }

  fclose(fd);

  return 0;
}

/**
 * Erase CDDB data from local directory.
 * @param path a string containing the path to the directory containig
 *        the local CDDB data files.
 * @param discid an unsigned long specifying the id of the CD whose CDDB
 *        data is to be erased.
 * @return 0 on success, -1 on failure.
 */
int cddb_erase_local(const char *path,unsigned long discid)
{
  int len;
  char file[PATH_MAX];

  len=strlen(path);
  if(path[len-1]==PATHSEP)
    snprintf(file,sizeof(file),"%s%08lx",path,discid);
  else
    snprintf(file,sizeof(file),"%s%c%08lx",path,PATHSEP,discid);

  if(unlink(file)<0)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Could not remove file %s",file);
    return -1;
  }

  return 0;
}

/**
 * Set CDDB submission mode to test.
 * @param test an integer specifying the CDDB submission mode.  Zero indicates
 *        normal submission mode, non-zero indicates test submission mode.
 */
void cddb_set_test_submit(int test)
{
  cddb_test_submit=test;
}

/**
 * Get current CDDB submission mode.
 * @return 0 if not test submission mode, non-zero if test submission mode.
 */
int cddb_get_test_submit()
{
  return cddb_test_submit;
}

/**
 * Submit CDDB data to a CDDB server.  Data can be submitted via HTTP or
 * SMTP.  Submissions can only be made with the US_ASCII and
 * ISO-8859-1 characeter sets.  If the variable 'cddb_test_submit' is set
 * to a non-zero value, the data will be sent to the specified CDDB server
 * in test mode when doing an HTTP submit.
 * @param host a cddb_host structure specifying the CDDB
 *        server with which to connect.
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value
 *        should be NULL.
 * @param hello a cddb_hello structure containing the name and version
 *        number of the program that is writing the CDDB data.  For HTTP
 *        submissions only the 'hello_program' and 'hello_version' fields
 *        need to be filled.  The 'hello_user' and 'hello_hostname' fields will
 *        be ignored.  For SMTP submissions the 'hello_program', hello_version',
 *        and 'hello_hostname' fields will have to be filled.
 * @param info a disc_info structure containing the frame offsets and total
 *        length for the CD whose CDDB data is to be written.  Obtained from
 *        the 'cd_stat' function.
 * @param data a disc_data structure containing the CDDB data to be written.
 * @param comment a character string specifying a comment to be added to the
 *        CDDB data.  This parameter is optional, and may be NULL.
 * @param email_address a character string specifying the user's email address.
 * @param submit_address a character string specifying the submission email address.
 *        Typically 'freedb-submit@freedb.org' for actual submissions and
 *        'test-submit@freedb.org' for test submissions.
 * @param mime_type an integer specifying that the MIME "quoted-printable" scheme
 *        is to be used with SMTP.  Use this scheme to submit entries containing 8-bit
 *        characters (for accents such as umlaut, or other extended characters).
 *        Set to 1 to enable, 0 to disable.
 * @return 0 on success, -1 on failure.
 */
int cddb_submit(const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello *hello,const struct disc_info *info,const struct disc_data *data,const char *comment,const char *email_address,...)
{
  int mime_type;
  long length;
  char outbuffer[BUFSIZ],*submit_address;
  cdsock_t sock;
  FILE *fd;

  /* Generate data in temp file.  */
  if((fd=tmpfile())==NULL)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Could not create temporary file");
    return -1;
  }

  /* Write data.  */
  if(cddb_write_local_file(fd,hello,info,data,comment)<0)
  {
    snprintf(cddb_message,sizeof(cddb_message),"Error generating temporary data file");
    fclose(fd);
    return -1;
  }

  /* Calculate length and reset file position.  */
  length=ftell(fd);
  fseek(fd,0,SEEK_SET);
  length-=ftell(fd);
  if(ferror(fd))
  {
    snprintf(cddb_message,sizeof(cddb_message),"Error calculating data legth");
    fclose(fd);
    return -1;
  }

  /* Connect to server.  */
  if(proxy!=NULL)
  {
    if((sock=cddb_connect_server(proxy))==INVALID_CDSOCKET)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Failed to connect with proxy server");
      fclose(fd);
      return -1;
    }
  }
  else
  {
    if((sock=cddb_connect_server(&host->host_server))==INVALID_CDSOCKET)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Failed to connect with %s",host->host_server.server_name);
      fclose(fd);
      return -1;
    }
  }

  if(host->host_protocol==CDDB_SUBMIT_SMTP)
  {
    /* Send SMTP header.  */
    va_list arglist;
    va_start(arglist,email_address);
    submit_address=va_arg(arglist,char *);
    mime_type=va_arg(arglist,int);

    /* Read the opening message.  */
    if(cddb_read_line(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"220",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send HELO.  */
    snprintf(outbuffer,sizeof(outbuffer),"HELO %s\r\n",hello->hello_hostname);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"250",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send FROM.  */
    snprintf(outbuffer,sizeof(outbuffer),"MAIL FROM: <%s>\r\n",email_address);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"250",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send RCPT.  */
    snprintf(outbuffer,sizeof(outbuffer),"RCPT TO: <%s>\r\n",submit_address);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"250",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send DATA.  */
    snprintf(outbuffer,sizeof(outbuffer),"DATA\r\n");
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"354",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send our info.  */
    snprintf(outbuffer,sizeof(outbuffer),"From: %s\r\n",email_address);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"To: %s\r\n",submit_address);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"X-Cddbd-Note: Sent by %s - Questions? contact %s maintainer\n",hello->hello_program,hello->hello_program);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"Subject: cddb %s %08lx\r\n",cddb_categories[(data->data_category<CDDB_UNKNOWN||data->data_category>CDDB_SOUNDTRACK)?CDDB_UNKNOWN:data->data_category],data->data_id);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if (mime_type)
    {
      snprintf(outbuffer,sizeof(outbuffer),"MIME-Version: 1.0\r\n"
                                           "Content-Type: text/plain; charset=ISO-8859-1\r\n"
                                           "Content-Transfer-Encoding: quoted-printable\r\n");
      if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
      {
        snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
        cddb_close(sock);
        fclose(fd);
        return -1;
      }
    }

    /* Start body.  */
    if(send(sock,"\r\n",2,0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    va_end(arglist);
  }
  else
  {
    /* Send HTTP header.  */
    if (proxy!=NULL)
      snprintf(outbuffer,sizeof(outbuffer),"POST http://%s:%d%s HTTP/1.0\r\n",host->host_server.server_name,host->host_server.server_port,host->host_addressing);
    else
      snprintf(outbuffer,sizeof(outbuffer),"POST %s HTTP/1.0\r\n",host->host_addressing);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"Category: %s\r\n",cddb_categories[(data->data_category<CDDB_UNKNOWN||data->data_category>CDDB_SOUNDTRACK)?CDDB_UNKNOWN:data->data_category]);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"Discid: %08lx\r\n",data->data_id);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"User-Email: %s\r\n",email_address);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"Submit-Mode: %s\r\n",(cddb_test_submit!=0)?"test":"submit");
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"X-Cddbd-Note: Sent by %s - Questions? contact %s maintainer\r\n",hello->hello_program,hello->hello_program);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    snprintf(outbuffer,sizeof(outbuffer),"Content-Length: %ld\r\n\r\n",length);
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }
  }

  /* Send cd data.  */
  while(!feof(fd))
  {
    fgets(outbuffer,sizeof(outbuffer),fd);
    if(!feof(fd))
    {
      if(ferror(fd))
      {
        snprintf(cddb_message,sizeof(cddb_message),"Error reading from temporary data file");
        cddb_close(sock);
        fclose(fd);
        return -1;
      }

      if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
      {
        snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
        cddb_close(sock);
        fclose(fd);
        return -1;
      }
    }
  }

  if(host->host_protocol==CDDB_SUBMIT_SMTP)
  {
    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"250",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    /* Send QUIT.  */
    snprintf(outbuffer,sizeof(outbuffer),"QUIT\r\n");
    if(send(sock,outbuffer,strlen(outbuffer),0)==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    if(strncmp(cddb_message,"221",3)!=0)
    {
      cddb_close(sock);
      fclose(fd);
      return -1;
    }

    strncpy(cddb_message,"OK, submission has been sent",sizeof(cddb_message));
  }
  else
  {
    cddb_skip_http_header(sock);

    if(cddb_read_reply(sock,cddb_message,sizeof(cddb_message))==CDSOCKET_ERROR)
    {
      snprintf(cddb_message,sizeof(cddb_message),"Connection to server lost");
      cddb_close(sock);
      fclose(fd);
      return -1;
    }
  }

  cddb_close(sock);
  fclose(fd);

  return 0;
}

/**
 * Query CDDB for an entry corresponding to a specified CDDB id
 * via HTTP.  Simply calls the 'cddb_connect', 'cddb_query', and
 * 'cddb_quit' functions, in that order.  Provided to simplify use
 * of HTTP with CDDB.
 * @param querystr a character string, specifying the CDDB id and disk
 *        track info required for a CDDB query, obtained from 'cddb_query_string'.
 * @param host a cddb_host structure specifying the CDDB
 *        server with which to connect.
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value
 *        should be NULL.
 * @param hello a cddb_hello structure specifying the name and version
 *        of the application connecting to the CDDB server.
 * @param query a cddb_query structure to be filled with CDDB query info.
 * @return 0 on success, -1 on failure.
 */
int cddb_http_query(const char *querystr,const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello* hello,struct cddb_query *query)
{
  int len=CDDB_LINE_SIZE;
  char *http_string;
  cdsock_t sock;

  /* Make sure mode is correct.  */
  if(host->host_protocol!=CDDB_MODE_HTTP)
    return -1;

  /* Connect.  */
  http_string=(char *)malloc(len);
  if((sock=cddb_connect(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
  {
    free(http_string);
    if(len!=0)
    {
      /* Insufficient space for http_string */
      http_string=(char *)malloc(len);
      if((sock=cddb_connect(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
      {
        free(http_string);
        return -1;
      }
    }
    else
      return -1;
  }

  /* Query.  */
  if(cddb_query(querystr,sock,host->host_protocol,query,http_string)<1)
  {
    cddb_close(sock);
    free(http_string);
    return -1;
  }

  cddb_quit(sock,host->host_protocol);

  free(http_string);

  return 0;
}

/**
 * Read CDDB data for a specified CDDB entry via HTTP.   Simply calls
 * the 'cddb_connect', 'cddb_read', and 'cddb_quit' functions, in that
 * order.  Provided to simplify use of HTTP with CDDB.
 * @param category an integer specifying the category for the disc whose
 *        data is to be retrieved.
 * @param discid an unsigned long specifying the id for the disc whose data
 *        is to be retrieved.
 * @param host a cddb_host structure specifying the CDDB
 *        server with which to connect.
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value
 *        should be NULL.
 * @param hello a cddb_hello structure specifying the name and version
 *        of the application connecting to the CDDB server.
 * @param data a disc_data structure to be filled with the retrieved CDDB data.
 * @return 0 on success, -1 on failure.
 */
int cddb_http_read(int category,unsigned long discid,const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello* hello,struct disc_data *data)
{
  int len=CDDB_LINE_SIZE;
  char *http_string;
  cdsock_t sock;

  /* Make sure mode is correct.  */
  if(host->host_protocol!=CDDB_MODE_HTTP)
    return -1;

  /* Connect.  */
  http_string=(char *)malloc(len);
  if((sock=cddb_connect(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
  {
    free(http_string);
    if(len!=0)
    {
      /* Insuifficient space for http_string */
      http_string=(char *)malloc(len);
      if((sock=cddb_connect(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
      {
        free(http_string);
        return -1;
      }
    }
    else
      return -1;
  }

  /* Read.  */
  if(cddb_read(category,discid,sock,host->host_protocol,data,http_string)<1)
  {
    cddb_close(sock);
    free(http_string);
    return -1;
  }

  cddb_quit(sock,host->host_protocol);

  free(http_string);

  return 0;
}

/**
 * Retrieve CDDB server list via http.  Simply calls
 * the 'cddb_connect', 'cddb_sites', and 'cddb_quit' functions, in that
 * order.  Provided to simplify use of HTTP with CDDB.
 * @param host a cddb_host structure specifying the CDDB
 *        server with which to connect.
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value
 *        should be NULL.
 * @param hello a cddb_hello structure specifying the name and version
 *        of the application connecting to the CDDB server.
 * @param list a cddb_serverlist structure to be filled with the retrieved server data.
 * @return 0 on success, -1 on failure.
 */
int cddb_http_sites(const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello* hello,struct cddb_serverlist *list)
{
  int len=CDDB_LINE_SIZE;
  char *http_string;
  cdsock_t sock;

  /* Make sure mode is correct.  */
  if(host->host_protocol!=CDDB_MODE_HTTP)
    return -1;

  /* Connect.  */
  http_string=(char *)malloc(len);
  if((sock=cddb_connect(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
  {
    free(http_string);
    if(len!=0)
    {
      /* Insuifficient space for http_string */
      http_string=(char *)malloc(len);
      if((sock=cddb_connect(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
      {
        free(http_string);
        return -1;
      }
    }
    else
      return -1;
  }

  /* Read.  */
  if(cddb_sites(sock,host->host_protocol,list,http_string)<1)
  {
    cddb_close(sock);
    free(http_string);
    return -1;
  }

  cddb_quit(sock,host->host_protocol);

  free(http_string);

  return 0;
}

/**
 * Fully initiate a connection with a CDDB server.  Simply calls
 * the 'cddb_connect', 'cddb_handshake', and 'cddb_proto' functions,
 * in that order.  Provided to simplify use of CDDBP with CDDB (but
 * can also be used with HTTP; equivalent to 'cddb_connect' when used
 * with HTTP).  With CDDBP, calling the "cddb_connect', "cddb_handshake',
 * and 'cddb_proto' functions separately allows the calling program to
 * analyze the 'cddb_message' string containing the CDDB server response
 * for each function individually.
 * @param host a cddb_host structure specifying the CDDB
 *        server with which to connect.
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value
 *        should be NULL.
 * @param hello a cddb_hello structure specifying the name and version
 *        of the application connecting to the CDDB server.
 * @param http_string a variable argument only required when using HTTP.
 *        This is a character array to be filled by the function with a
 *        CDDB handshake string.  This string will be required for further
 *        HTTP queries.  Note that the string for CDDB queries differs from
 *        the string for CDDB submissions.  When using CDDB with HTTP, separate
 *        connections for CDDB queries and submissions are required.
 * @param https_string_len a variable argument only required when using HTTP.
 *        This is an integer specifying the size of the http_string character array.
 * @return handle to a connected socket on success,
 *         INVALID_CDSOCKET on failure.
 */
cdsock_t cddb_initiate(const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello *hello,...)
{
  cdsock_t sock;
  int *http_string_len;
  char *http_string;

  if(host->host_protocol==CDDB_MODE_HTTP)
  {
    va_list arglist;
    va_start(arglist,hello);
    http_string=va_arg(arglist,char *);
    http_string_len=va_arg(arglist,int *);

    if((sock=cddb_connect(host,proxy,hello,http_string,http_string_len))==INVALID_CDSOCKET)
      return INVALID_CDSOCKET;

    va_end(arglist);
  }
  else
  {
    if((sock=cddb_connect(host,proxy))==INVALID_CDSOCKET)
      return INVALID_CDSOCKET;

    if(cddb_handshake(sock,hello)<1)
    {
      cddb_close(sock);
      return INVALID_CDSOCKET;
    }

    if(cddb_proto(sock)<1)
    {
      cddb_close(sock);
      return INVALID_CDSOCKET;
    }
  }

  return sock;
}

/**
 * Complete a full CDDB transaction for retrieving the data from a specified
 * CD.  If multiple data entries are available, the first one will be
 * chosen.  Provided as a convenience.
 * @param cd_desc the handle to the cd device containing CD for which to
 *        obtain CDDB data.
 * @param host a cddb_host structure specifying the CDDB
 *        server with which to connect.
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value
 *        should be NULL.
 * @param hello a cddb_hello structure specifying the name and version
 *        of the application connecting to the CDDB server.
 * @param data a disc_data structure to be filled with the retrieved CDDB data.
 * @return 1 if an entry is found, 0 if no entry is found, and -1 if an
 *         error is encountered.
 */
int cddb_read_data(cddesc_t cd_desc,const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello *hello,struct disc_data *data)
{
  int len=CDDB_LINE_SIZE;
  char *query_string,*http_string=NULL;
  cdsock_t sock;
  struct cddb_query query;

  /* Get Query string.  */
  query_string=(char *)malloc(len);
  if(cddb_query_string(cd_desc,query_string,&len)==NULL)
  {
    free(query_string);
    if(len!=0)
    {
      query_string=(char *)malloc(len);
      if(cddb_query_string(cd_desc,query_string,&len)==NULL)
      {
        free(query_string);
        return -1;
      }
    }
    else
      return -1;
  }

  /* Connect.  */
  if(host->host_protocol==CDDB_MODE_HTTP)
  {
    len=CDDB_LINE_SIZE;
    http_string=(char *)malloc(len);
    if((sock=cddb_initiate(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
    {
      free(http_string);
      if(len!=0)
      {
        http_string=(char *)malloc(len);
        if((sock=cddb_initiate(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
        {
          free(http_string);
          free(query_string);
          return -1;
        }
      }
      else
      {
        free(query_string);
        return -1;
      }
    }
  }
  else
  {
    if((sock=cddb_initiate(host,proxy,hello))==INVALID_CDSOCKET)
    {
      free(query_string);
      return -1;
    }
  }

  /* Query.  */
  cddb_init_cddb_query(&query);
  if(cddb_query(query_string,sock,host->host_protocol,&query,http_string)<1)
  {
    cddb_close(sock);
    free(query_string);
    cddb_free_cddb_query(&query);
    if(host->host_protocol==CDDB_MODE_HTTP) free(http_string);
    return -1;
  }

  free(query_string);
  if(host->host_protocol==CDDB_MODE_HTTP) free(http_string);

  /* Check for match.  */
  if(query.query_match==QUERY_NOMATCH||query.query_matches==0)
  {
    cddb_close(sock);
    cddb_free_cddb_query(&query);
    return 0;
  }

  /* One HTTP command per socket session; Connect again.  */
  if(host->host_protocol==CDDB_MODE_HTTP)
  {
    /* Close old socket.  */
    cddb_quit(sock,host->host_protocol);

    /* Open new socket.  */
    len=CDDB_LINE_SIZE;
    http_string=(char *)malloc(len);
    if((sock=cddb_initiate(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
    {
      free(http_string);
      if(len!=0)
      {
        http_string=(char *)malloc(len);
        if((sock=cddb_initiate(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
        {
          free(http_string);
          cddb_free_cddb_query(&query);
          return -1;
        }
      }
      else
      {
        cddb_free_cddb_query(&query);
        return -1;
      }
    }
  }

  /* Grab first match in list.  */
  if(cddb_read(query.query_list[0].list_category,query.query_list[0].list_id,sock,host->host_protocol,data,http_string)<1)
  {
    cddb_close(sock);
    cddb_free_cddb_query(&query);
    if(host->host_protocol==CDDB_MODE_HTTP) free(http_string);
    return -1;
  }

  cddb_quit(sock,host->host_protocol);

  cddb_free_cddb_query(&query);
  if(host->host_protocol==CDDB_MODE_HTTP) free(http_string);

  return 1;
}

/**
 * Complete a full CDDB transaction for a retrieving a list of CDDB server
 * sites.  Provided as a convenience.
 * @param host a cddb_host structure specifying the CDDB
 *        server with which to connect.
 * @param proxy a cddb_server structure specifying the proxy server
 *        to connect through.  If there is no proxy server this value
 *        should be NULL.
 * @param hello a cddb_hello structure specifying the name and version
 *        of the application connecting to the CDDB server.
 * @param list a cddb_serverlist structure to be filled with the retrieved server data.
 * @return 0 on success, -1 on failure.
 */
int cddb_read_sites(const struct cddb_host *host,const struct cddb_server *proxy,const struct cddb_hello *hello,struct cddb_serverlist *list)
{
  int len=CDDB_LINE_SIZE;
  char *http_string;
  cdsock_t sock;

  /* Connect.  */
  if(host->host_protocol==CDDB_MODE_HTTP)
  {
    http_string=(char *)malloc(len);
    if((sock=cddb_initiate(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
    {
      free(http_string);
      if(len!=0)
      {
        http_string=(char *)malloc(len);
        if((sock=cddb_initiate(host,proxy,hello,http_string,&len))==INVALID_CDSOCKET)
        {
          free(http_string);
          return -1;
        }
      }
      else
        return -1;
    }
  }
  else
  {
    if((sock=cddb_initiate(host,proxy,hello))==INVALID_CDSOCKET)
      return -1;
  }

  /* Get server list.  */
  if(cddb_sites(sock,host->host_protocol,list,http_string)<1)
  {
    cddb_close(sock);
    if(host->host_protocol==CDDB_MODE_HTTP) free(http_string);
    return -1;
  }

  cddb_quit(sock,host->host_protocol);

  if(host->host_protocol==CDDB_MODE_HTTP) free(http_string);

  return 0;
}
